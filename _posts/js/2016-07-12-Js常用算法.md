---
layout: post
filename: 2016-07-12-Js常用算法
title: Js常用算法
date: 2016-07-12 16:09:24 +0800
categories: Js
tags: Js 算法
---

### 数组去重

```javascript
Array.prototype.unique = function() {
    var n = {},
        r = []; //n为hash表，r为临时数组 
    for (var i = 0; i < this.length; i++) //遍历当前数组 
    {
        if (!n[this[i]]) //如果hash表中没有当前项 
        {
            n[this[i]] = true; //存入hash表 
            r.push(this[i]); //把当前数组的当前项push到临时数组里面 
        }
    }
    return r;
}
```

### 二分查找

>有缺陷就是要求数字是预先排序好的

#### 方法一：

```javascript
Array.prototype.binarySearch = function(obj) {
    var value = 0;
    var left = 0;
    var right = this.length;
    while (left <= right) { // 判断长度
        var center = Math.floor((left + right) / 2); //获取中间值
        if (this[center] == obj) {
            value = center;
            break;
        } else if (obj < this[center]) {
            right = center - 1;
        } else {
            left = center + 1;
        }
    }
    return value;
};

//如下为测试代码： 
function testArrayBinarySearch() {
    var array = new Array();
    var key = 678;
    var number = 1000;
    for (i = 0; i < number; i++) {
        array.push(i);
    }
    return array.binarySearch(key);
}
testArrayBinarySearch();
```

#### 方法二：

```javascript
function binarySearch(items, value) {
    var startIndex = 0,
        stopIndex = items.length - 1,
        middle = Math.floor((stopIndex + startIndex) / 2);
    while (items[middle] != value && startIndex < stopIndex) {
        //adjust search area（调整查找范围） 
        if (value < items[middle]) {
            stopIndex = middle - 1;
        } else if (value > items[middle]) {
            startIndex = middle + 1;
        }
        //recalculate middle（重新计算中项索引） 
        middle = Math.floor((stopIndex + startIndex) / 2);
    }
    //make sure it's the right value（确保返回正确的值） 
    return (items[middle] != value) ? -1 : middle;
}

var item = [1,2,4,6,8,9];
var key = 8;
binarySearch(item, key)
```

### 随机取值(eg:十六进制颜色值的随机生成)

```javascript
function randomColor() {
    var arrHex = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'], strHex = '#';
    while (strHex.length < 7) {
        var index = Math.round(Math.random() * 15);
        strHex += arrHex[index];
    }
    return strHex;
}
randomColor();
```

### 线性查找-时间复杂度O(n)

```javascript
//线性搜索(入门HelloWorld)
//A为数组，x为要搜索的值
function linearSearch(A, x) {
  for (var i = 0; i < A.length; i++) {
    if (A[i] == x) {
      return i;
    }
  }
  return -1;
}
```

## 各类排序算法

### 冒泡排序 - 时间复杂度O(n^2)

```javascript
//冒泡排序
function bubbleSort(A) {
  for (var i = 0; i < A.length; i++) {
    var sorted = true;
  //注意：内循环是倒着来的
    for (var j = A.length - 1; j > i; j--) {
      if (A[j] < A[j - 1]) {
        swap(A, j, j - 1);
        sorted = false;
      }
    }
    if (sorted) {
      return;
    }
  }
}
function swap(a, i, j) {
    var tmp = a[i];
    a[i] = a[j]*1;
    a[j] = tmp*1;
}
```

### 选择排序 -- 时间复杂度O(n^2)

```javascript
//选择排序
//思路：找到最小值的下标记下来，再交换
function selectionSort(A) {
  for (var i = 0; i < A.length - 1; i++) {
    var k = i;
    for (var j = i + 1; j < A.length; j++) {
      if (A[j] < A[k]) {
        k = j;
      }
    }
    if (k != i) {
      var t = A[k];
      A[k] = A[i];
      A[i] = t;
      println(A);
    }
  }
  return A;
}
```

### 插入排序 -- 时间复杂度O(n^2)

```javascript
//插入排序
//假定当前元素之前的元素已经排好序，先把自己的位置空出来，
//然后前面比自己大的元素依次向后移，直到空出一个"坑"，
//然后把目标元素插入"坑"中
function insertSort(A) {
  for (var i = 1; i < A.length; i++) {
    var x = A[i];
    for (var j = i - 1; j >= 0 && A[j] > x; j--) {
      A[j + 1] = A[j];
    }
    if (A[j + 1] != x) {
      A[j + 1] = x;
      println(A);
    }
  }
  return A;
}
```

### 字符串反转 -- 时间复杂度O(logN)

```javascript
//字符串反转(比如：ABC -> CBA)
function inverse(s) {
  var arr = s.split('');
  var i = 0, j = arr.length - 1;
  while (i < j) {
    var t = arr[i];
    arr[i] = arr[j];
    arr[j] = t;
    i++;
    j--;
  }
  return arr.join('');
}
```

参考：

[经典排序算法](http://www.cnblogs.com/kkun/archive/2011/11/23/2260312.html)