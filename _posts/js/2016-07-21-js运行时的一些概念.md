---
layout: post
filename: 2016-07-21-js运行时的一些概念
title: js运行时的一些概念
date: 2016-07-21 18:21:08 +0800
categories: Js
tags: Js运行概念
---

1. 栈 Stack
2. 堆 Heap
3. 队列 Queue

### 栈 Stack

函数调用形成了一个 frames 的栈。

```javascript
function f(b){
  var a = 12;
  return a+b+35;
}

function g(x){
  var m = 4;
  return f(m*x);
}

g(21);
```

调用g的时候，创建了第一个 frame，包含了 g 的参数和局部变量。当 g 调用 f 的时候，第二个 frame 就被创建、并置于第一个 frame 之上，包含了 f 的参数和局部变量。当f返回时，最上层的 frame 就出栈了（剩下 g 函数调用的 frame）。当g返回的时候，栈就空了。

### 堆 Heap

对象被分配在一个堆中，一个用以表示一个内存中大的未被组织的区域。

### 队列 Queue

一个 JavaScript 运行时包含了一个待处理的消息队列。每一个消息都与一个函数相关联。当栈为空时，从队列中取出一个消息进行处理。这个处理过程包含了调用与这个消息相关联的函数（以及因此而创建的一个初始栈结构）。当栈再次为空的时候，也就意味着消息处理结束。

### 添加监听

在浏览器里，当一个事件出现且有一个事件监听器被绑定时，消息会被随时添加。如果没有事件监听器，事件会丢失。所以点击一个附带点击事件处理函数的元素会添加一个消息。其它事件亦然。

调用 setTimeout 函数会在一个时间段过去后在队列中添加一个消息。这个时间段作为函数的第二个参数被传入。如果队列中没有其它消息，消息会被马上处理。但是，如果有其它消息，setTimeout 消息必须等待其它消息处理完。因此第二个参数仅仅表示最少的时间 而非确切的时间。

### 零延迟

零延迟 (Zero delay) 并不是意味着回调会立即执行。在零延迟调用 setTimeout 时，其并不是过了给定的时间间隔后就马上执行回调函数。其等待的时间基于队列里正在等待的消息数量。在下面的例子中，"this is just a message" 在将会在回调 (callback) 获得处理之前输出到控制台，这是因为延迟是要求运行时 (runtime) 处理请求所需的最小时间，但不是有所保证的时间。