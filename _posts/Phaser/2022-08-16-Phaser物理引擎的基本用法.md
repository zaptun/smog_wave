---
layout: post
filename: 2022-08-16-Phaser物理引擎的基本用法
title: Phaser物理引擎的基本用法
date: 2022-08-16 00:13:34 +0800
categories: 
tags: 
---

## 创建带物理引擎的场景

**Phaser3**中提供了两种物理引擎，分别为**Arcade**与**Matter**。它们在Phaser中的命名空间分别为**Phaser.Physics.Arcade**与**Phaser.Physics.Matter**。Arcade相对简单，物体的形状只支持矩形与圆形两种；Matter则要强大很多，能模拟更多的物理效果。

我们还是先通过Phaser提供的工程模板来创建工程

我们分两个场景来分别研究Arcade与Matter。方便起见我们把场景以类的形式来写，在src下新建scenes文件夹，然后在该文件夹下分别创建arcade.js与matter.js。

#### arcade.js

初始代码如下

```javascript
import { Scene } from "phaser";
export class StudyArcade extends Scene {
    constructor() {
        super({
            key: 'StudyArcade',      
            // 物理引擎设置 
            physics: {
                default: 'arcade', 
                arcade: {          
                    // 重力   
                    gravity: { y: 10 },
                },
                // 开启debug模式    
                debug: true,
            }
        })
    }
    /**   * 加载资源   */
    preload() { }
    /**   * 创建内容   */
    create() { 
        console.log("I am Arcade") 
    }
    /**   * 更新内容   */
    update() { }
} 
export default StudyArcade
```

#### matter.js

初始内容与arcade.js除了配置物理引擎的地方外都一样

```javascript
import { Scene } from "phaser";
export class StudyMatter extends Scene {
    constructor() {
            super({
                key: "StudyMatter",
                physics: {
                    default: "matter",
                    matter: {
                        gravity: { y: 10 },
                    },
                    // 开启debug模式    
                    debug: true,
                }
            })
        }
    /**   * 加载资源   */
    preload() {}
    /**   * 创建内容   */
    create() { console.log("I am Matter") }
    /**   * 更新内容   */
    update() {}
}
export default StudyMatter;
```

#### 创建场景

```javascript
import Phaser from "phaser";
import StudyArcade from "./scenes/arcade";
import StudyMatter from "./scenes/matter";
const config = {
    type: Phaser.AUTO,
    parent: "phaser-example",
    width: 800,
    height: 600,
    // 配置场景，第一个为默认场景
    scene: [StudyArcade, StudyMatter],
};
// 创建游戏实例
const game = new Phaser.Game(config);
```

## World

世界
首先我们需要理解物理引擎中的“世界”，可以把它理解成是一个盒子，大小默认与游戏画布相同。也就是说物理引擎的世界是有范围的，所有的模拟都是在世界范围内，世界以外的地方不会考虑。

场景会自动创建物理引擎实例，使用this.physics即可使用arcade引擎实例。如果要修改世界的相关属性，可以直接使用this.physics.world来操作。如

```javascript
// 修改世界的边界
this.physics.world.setBounds(x, y, width, height)
```

## Body

body是用于描述物理系统中物体的对象，比如速度、质量、重力、弹力等都是body的属性。一个普通的游戏对象是没有body的，但可以通过给普通游戏对象添加body使之拥有物理属性。

body分为静态与动态两种:
- **Arcade.STATIC_BODY**: 静态body(Arcade.STATIC_BODY)用于模拟如大地或建筑物这种不会移动的物体；
- **Arcade.DYNAMIC_BODY**: 动态body(Arcade.DYNAMIC_BODY)用于模拟会因速度与加速度(受力)而移动的物体。

一个物理对象可以直接通过body来操作相关属性，如

```javascript
// rock是一个物理对象，修改其body的角速度
rock.body.setAngularVelocity(100);
```

## 添加物理对象

通常在场景中添加普通的游戏对象是这样的

```javascript
// 添加一个图片对象
const ball = this.add.image(400, 100, 'ball');
```

此时这个ball并没有物理body对象，即其不会参与到Arcade的物理系统中，如果想让它加入到物理系统中，需要这样

```javascript
// 为ball创建body对象，即加入到了物理系统中
this.physics.world.enable(ball);
```

此时ball上的body会自动将ball的尺寸与位置等信息进行同步。如果只是使用image生成物理对象的话，这样略显繁琐，实际上可以直接像下面这样添加一个物理对象

```javascript
// arcade.js 
...create() {  
    // 通过物理引擎添加一个图片对象到场景中
    const ball = this.physics.add.image(400, 100, 'ball')

    // 或者

    /* 加入到物理世界 */
    const ball = this.add.image(400, 100, 'ball')
    this.physics.add.existing(ball);
    this.physics.world.enable(ball);
}
```

## 组Group

前面有提到，如果希望物体有碰撞需要明确声明。只有两三个物体时还好办，当物体比较多时似乎就比较麻烦了，而且物体经常是在游戏过程中动态生成的，那样岂不是更麻烦。

这时就需要用到组的功能了。我们可以简单的把组理解成标签，一个物体可以在多个组(有多个标签)，一个组自然也可以有多个物体。

组有两种，一个是Phaser的游戏对象组Phaser.GameObjects.Group，我们姑且称之为“对象组”；一个是Arcade的组Phaser.Physics.Arcade.Group，我们姑且称之为“物理组”。

对象组不关心其成员是否为物理对象，就是纯粹的分组功能；物理组除了分组外，还能提供一些使游戏对象物理化的便捷功能，即添加到物理组的对象如果没有物理body则会被自动添加上body。

```javascript
// 创建一个物理组
const shipGroup = this.physics.add.group();
// 创建一个物理对象并添加到 shipGroup
shipGroup.create(400, 100, 'ship')
```

### 静态物理组

与普通物理组一样，只是由静态物理组创建的物理对象也都静态的，可以用它方便的创建与管理静态对象。

```javascript
// 创建一个静态物理组
const platforms = this.physics.add.staticGroup();
// 通过静态物理组直接创建一个静态物理对象
platforms.create(600, 200, 'rock');
// 让球与静态物理组中的对象可以碰撞
this.physics.add.collider(ball, platforms);
```

```javascript
// 创建一个静态物理组，并自动生成10个“砖块”
const platforms = this.physics.add.staticGroup({
    // 使用石块图片  
    key: 'rock',
    // 一共生成10个(第一次创建后再重复创建9次)  
    repeat: 9,
    // 设置缩放  
    setScale: { x: 0.1, y: 0.1, },
    // 设置位置  
    setXY: {
        // 首次创建对象时的坐标    
        x: 500,
        y: 300,
        // 每次重复生成时 x坐标的增量    
        stepX: 25,
    }
});
// 由于静态物体body不会自动同步对象的大小与位置等信息，所以需要手动刷新一下
platforms.children.iterate(child => child.refreshBody())
    
// 让球与静态物理组中的对象可以碰撞
this.physics.add.collider(ball, platforms);
```


## 设置与世界边界碰撞和常用属性

对象如果设置了重力可能会掉出边界，是因为没有设置与世界边界碰撞，添加如下设置

```javascript
// 设置球与边界发生碰撞
ball.setCollideWorldBounds(true);

// 设置弹跳系数，值越大，反弹越强
ball.setBounce(0.9);

// 设置水平速度
ball.setVelocityX(200);

// 添加碰撞检测对象
this.physics.add.collider(rock, ball);

// 当碰撞发生时执行doSomething方法
this.physics.add.collider(rock, ball, doSomething);

// 只检测碰撞是否发生，但不模拟碰撞效果
this.physics.add.overlap(rock, ball, doSomething)

// 设置摩擦力系数
rock.setFriction(0.6)
// 设置摩擦系数
ball.setFriction(0.9)

// 设置为圆形
ball.body.isCircle = true
```


----

参考

[https://blog.csdn.net/weixin_42510717/article/details/112705900](https://blog.csdn.net/weixin_42510717/article/details/112705900)

[https://opengameart.org/](https://opengameart.org/)
