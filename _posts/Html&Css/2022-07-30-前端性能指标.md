---
layout: post
filename: 2022-07-30-前端性能指标
title: 前端性能指标
date: 2022-07-30 20:51:35 +0800
categories: 前端性能指标
tags: DCL L FP FCP FMP LCP CLS LT TTI FID TBT
---

## 重要指标的演变

<img src="../images/post/前端性能指标07.png" />

## DCL 和 L

定义在 W3C标准/草案 [navigation timing(导航计时)][1]

| 名称 |  描述 |
|---|---|
| DCL (DOMContentLoaded) | 表示HTML加载完成事件 |
| L (onLoad)|表示页面所有资源加载完成事件 |

>注：在 performance 和 Network 面板中都可以查看，但 DCL 和 L 在 Performance 和 Network 中展示的值是不同的,这是因为 Performance 中时间线的起点是你点击录制按钮的时间，而 Network 中时间线的起点是 fetchStart 事件。


## FP 和 FCP

定义在 W3C标准/草案 [Paint timing(渲染计时器)][2]

| 名称 |  描述 |
|---|---|
| FP (First Paint) | （白屏）页面在导航后首次呈现出不同于导航前内容的时间|
| FCP (First Contentful Paint) | 首次绘制任何文本，图像，非空白canvas或SVG的时间点 |

大部分情况FP 和 FCP都是一样的,所以简单介绍一下FCP.

#### 什么是 FCP？

首次内容绘制 (FCP) 指标测量页面从开始加载到页面内容的任何部分在屏幕上完成渲染的时间。对于该指标，"内容" 指的是文本、图像（包括背景图像）、`<svg>`元素或非白色的`<canvas>`元素。

<img src="../images/post/前端性能指标05.png" />

在上方的加载时间轴中，FCP 发生在第二帧，因为那是首批文本和图像元素在屏幕上完成渲染的时间点。

#### FCP多少是好

为了提供良好的用户体验，网站应该努力将首次内容绘制控制在1.8 秒或以内。为了确保您能够在大部分用户的访问期间达成建议目标值，一个良好的测量阈值为页面加载的第 75 个百分位数，且该阈值同时适用于移动和桌面设备。

<img src="../images/post/前端性能指标04.png" style="zoom:60%" />

#### 测量 FCP

可以用很多现成的库，或者chrome开发者工具，或者 灯塔

要在 JavaScript 中测量 FCP，您可以使用绘制计时 API。以下示例说明了如何创建一个PerformanceObserver来侦听名称为first-contentful-paint的paint条目并记录在控制台中。

```javascript
new PerformanceObserver((entryList) => {
  for (const entry of entryList.getEntriesByName('first-contentful-paint')) {
    console.log('FCP candidate:', entry.startTime, entry);
  }
}).observe({type: 'paint', buffered: true});
```
#### 改进 FCP

要了解改进 FCP 的常见方式（针对任何网站），请参阅以下性能指南：

- [消除阻塞渲染的资源](https://web.dev/render-blocking-resources/)
- [缩小 CSS](https://web.dev/unminified-css/)
- [移除未使用的 CSS](https://web.dev/unused-css-rules/)
- [预连接到所需的来源](https://web.dev/uses-rel-preconnect/)
- [减少服务器响应时间 (TTFB)](https://web.dev/ttfb/)
- [避免多个页面重定向](https://web.dev/redirects/)
- [预加载关键请求](https://web.dev/uses-rel-preload/)
- [避免巨大的网络负载](https://web.dev/total-byte-weight/)
- [使用高效的缓存策略服务静态资产](https://web.dev/uses-long-cache-ttl/)
- [避免 DOM 过大](https://web.dev/dom-size/)
- [最小化关键请求深度](https://web.dev/critical-request-chains/)
- [确保文本在网页字体加载期间保持可见](https://web.dev/font-display/)
- [保持较低的请求数和较小的传输大小](https://web.dev/resource-summary/)


## 尝试 FMP 和 LCP

[W3C Web 性能工作组][9] - 提供方法来衡量用户代理特性和应用程序api的性能。

尝试：FMP 和 SI LCP

| 名称 |  描述 |
|---|---|
| FMP <br> (First Meaningful Paint) | (首次有效绘制) 表示页面的“主要内容” 开始出现在屏幕上的时间点，这项指标因页<br>面逻辑而异，因此上不存在任何规范。 |
| LCP <br> (Largest contentful paint) | 最大内容绘制时间，用于记录视窗内最大的元素绘制的时间，该时间会随着页面<br>渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变，另外该指<br>标会在用户第一次交互后停止记录。|

#### FMP是什么和计算方式思路

- 主动上报：开发者在相应页面的「Meaning」位置上报时间
- 权重计算：根据页面元素，计算权重最高的元素渲染时间
- 趋势计算：在 render 期间，根据 dom 的变化趋势推算 FMP 值

>FMP Lighthouse 已经从6.0版本之后就废弃了. 所以不详细写了

#### 什么是 LCP？

最大内容绘制 (LCP) 指标会根据页面首次开始加载的时间点来报告可视区域内可见的最大图像或文本块完成渲染的相对时间。

#### LCP多少是好

为了提供良好的用户体验，网站应该努力将最大内容绘制控制在2.5 秒或以内。为了确保您能够在大部分用户的访问期间达成建议目标值，一个良好的测量阈值为页面加载的第 75 个百分位数，且该阈值同时适用于移动和桌面设备。

<img src="../images/post/前端性能指标08.png" style="zoom:50%" />

#### 怎么算是 LCP?

看几个例子：

<img src="../images/post/前端性能指标09.png" />
<img src="../images/post/前端性能指标10.png" />
<img src="../images/post/前端性能指标11.png" />
<img src="../images/post/前端性能指标12.png" />

#### 测量 LCP

可以用很多现成的库，或者chrome开发者工具，或者 灯塔

要在 JavaScript 中测量 LCP，您可以使用最大内容绘制 API 。以下示例说明了如何创建一个PerformanceObserver来侦听largest-contentful-paint条目并记录在控制台中。

```javascript
new PerformanceObserver((entryList) => {
  for (const entry of entryList.getEntries()) {
    console.log('LCP candidate:', entry.startTime, entry);
  }
}).observe({type: 'largest-contentful-paint', buffered: true});
```

#### 改进 LCP

LCP 主要受四个因素影响：

- 缓慢的服务器响应速度
- JavaScript 和 CSS 渲染阻塞
- 资源加载时间
- 客户端渲染

如需深入了解如何改进 LCP，请参阅[优化 LCP](https://web.dev/optimize-lcp/)。有关其他能够改进 LCP 的单个性能技巧的进一步指导，请参阅：

- [使用 PRPL 模式做到即时加载](https://web.dev/apply-instant-loading-with-prpl)
- [优化关键渲染路径](https://web.dev/critical-rendering-path/)
- [优化您的 CSS](https://web.dev/fast#optimize-your-css)
- [优化您的图像](https://web.dev/fast#optimize-your-images)
- [优化网页字体](https://web.dev/fast#optimize-web-fonts)
- [优化您的 JavaScript](https://web.dev/fast#optimize-your-javascript)（针对客户端渲染的网站）

<img src="../images/post/前端性能指标01.png" />

#### 首屏渲染完成

> **[MutationObserver][13]** 做首屏时间检测

## 重要标准

| 名称 |  描述 |
|---|---|
| [FCP (首次内容绘制)][3]<br> First contentful paint | 测量页面从开始加载到页面内容的任何部分在屏幕上完成渲染的时间 |
| [LCP (最大内容绘制)][4]<br> Largest contentful paint| 测量页面从开始加载到最大文本块或图像元素在屏幕上完成渲染的时间 |
| [TTI (可交互时间)][6]<br>Time to Interactive| 测量页面从开始加载到视觉上完成渲染、初始脚本（如果有的话）完成加载，<br>并能够快速、可靠地响应用户输入所需的时间|
| [FID (首次输入延迟)][5]<br> First input delay | 测量从用户第一次与您的网站交互（例如当他们单击链接、点按按钮或使用由<br>JavaScript 驱动的自定义控件）直到浏览器实际能够对交互做出响应所经过的时间 |
| [TBT (总阻塞时间)][7]<br>Total blocking time| 测量 FCP 与 TTI 之间的总时间，这期间，主线程被阻塞的时间过长，<br>无法作出输入响应 |
| [CLS (累积布局偏移)][8]<br>Cumulative layout shift |测量页面在开始加载和其生命周期状态变为隐藏期间发生的所有意外布局偏移的<br>累积分数。计算方式为：位移影响的面积 * 位移距离|

#### 什么是 TTI?

首次可交互时间。这个指标计算过程略微复杂，它需要满足以下几个条件：
- 从 FCP 指标后开始计算；
- 持续 5 秒内无长任务（执行时间超过 50 ms）且无两个以上正在进行中的 GET 请求；
- 往前回溯至 5 秒前的最后一个长任务结束的时间。

[长任务][12]（Long Task）：当一个任务执行时间超过50ms时消耗到的任务

图例步骤：

<img src="../images/post/前端性能指标14.png" />

#### TTI多少是好

为了提供良好的用户体验，网站在普通移动硬件上进行测试时，应该努力将可交互时间控制在**5秒以内**。

#### 测量 TTI

没有固定的监控方式，依页面而定，如果核心模块无脚本那么计算核心模块解析完成的时间即可；如果核心模块有相关脚本则需要计算脚本加载和绑定完成的时间。

但我们不建测量TTI，因为用户交互会影响您网页的 TTI，从而导致您的报告中出现大量差异。如需了解页面在实际情况中的交互性，应该测量First Input Delay 首次输入延迟 (FID) 。

#### 改进 TTI

如需了解如何改进某个特定网站的 TTI，您可以运行一次灯塔性能审计，并留心查看审计建议的各种具体[机会](https://web.dev/lighthouse-performance/#opportunities)。

如需了解改进 TTI 的常见方式（针对任何网站），请参阅以下性能指南：

- [缩小 JavaScript](https://web.dev/unminified-javascript/)
- [预连接到所需的来源](https://web.dev/uses-rel-preconnect/)
- [预加载关键请求](https://web.dev/uses-rel-preload/)
- [减少第三方代码的影响](https://web.dev/third-party-summary/)
- [最小化关键请求深度](https://web.dev/critical-request-chains/)
- [减少 JavaScript 执行时间](https://web.dev/bootup-time/)
- [最小化主线程工作](https://web.dev/mainthread-work-breakdown/)
- [保持较低的请求数和较小的传输大小](https://web.dev/resource-summary/)


#### 什么是 FID?

FID 测量从用户第一次与页面交互（例如当他们单击链接、点按按钮或使用由 JavaScript 驱动的自定义控件）直到浏览器对交互作出响应，并实际能够开始处理事件处理程序所经过的时间。

<img src="../images/post/前端性能指标16.png" />

#### FID多少是好

为了提供良好的用户体验，网站应该努力将首次输入延迟设控制在100 毫秒或以内

<img src="../images/post/前端性能指标15.png" />

#### 测量 FID

可以用很多现成的库，或者chrome开发者工具，或者 灯塔

要在 JavaScript 中测量 FID，您可以使用[事件计时 API][15]。以下示例说明了如何创建一个PerformanceObserver来侦听first-input条目并记录在控制台中：

```javascript
new PerformanceObserver((entryList) => {
  for (const entry of entryList.getEntries()) {
    const delay = entry.processingStart - entry.startTime;
    console.log('FID candidate:', delay, entry);
  }
}).observe({type: 'first-input', buffered: true});
```

#### 改进 FID

要了解如何改进某个特定网站的 FID，您可以运行一次灯塔性能审计，并留心查看审计建议的各种具体[机会](https://web.dev/lighthouse-performance/#opportunities)。

虽然 FID 是一项实际指标（而灯塔是一个实验室指标工具），但改进 FID 的指导方向与改进[总阻塞时间 (TBT)](https://web.dev/tbt/)这项实验室指标的指导方向相同。

如需深入了解如何改进 FID，请参阅[优化 FID](https://web.dev/optimize-fid/)。有关其他能够改进 FID 的单个性能技巧的进一步指导，请参阅：

- [减少第三方代码的影响](https://web.dev/third-party-summary/)
- [减少 JavaScript 执行时间](https://web.dev/bootup-time/)
- [最小化主线程工作](https://web.dev/mainthread-work-breakdown/)
- [保持较低的请求数和较小的传输大小](https://web.dev/resource-summary/)

#### 什么是 TBT?

总阻塞时间 (TBT) 指标测量[First Contentful Paint 首次内容绘制 (FCP)](https://web.dev/fcp/)与[Time to Interactive 可交互时间 (TTI)](https://web.dev/tti/)之间的总时间，这期间，主线程被阻塞的时间过长，无法作出输入响应。

每当出现长任务（在主线程上运行超过 50 毫秒的任务）时，主线程都被视作"阻塞状态"。我们说主线程处于"阻塞状态"是因为浏览器无法中断正在进行的任务。因此，如果用户在某个长任务运行期间与页面进行交互，那么浏览器必须等到任务完成后才能作出响应。

如果任务时长足够长（例如超过 50 毫秒），那么用户很可能会注意到延迟，并认为页面缓慢或卡顿。

某个给定长任务的阻塞时间是该任务持续时间超过 50 毫秒的部分。一个页面的总阻塞时间是在 FCP 和 TTI 之间发生的每个长任务的阻塞时间总和。

例如，请看以下这张页面加载期间浏览器主线程的图表：

<img src="../images/post/前端性能指标17.png" />

上方的时间轴上有五个任务，其中三个是长任务，因为这些任务的持续时间超过 50 毫秒。下图显示了各个长任务的阻塞时间：

<img src="../images/post/前端性能指标18.png" />

因此，虽然在主线程上运行任务的总时间为 560 毫秒，但其中只有 345 毫秒被视为阻塞时间。

|           | 任务持续时间 | 任务阻塞时间  |
| --------- | ------- | ---------- |
| 任务一     | 250 毫秒 | 200 毫秒   |
| 任务二     | 90 毫秒  | 40 毫秒    |
| 任务三     | 35 毫秒  | 0 毫秒     |
| 任务四     | 30 毫秒  | 0 毫秒     |
| 任务五     | 155 毫秒 | 105 毫秒   |
| **总阻塞时间** |        | **345 毫秒** |


#### TBT 多少是好

为了提供良好的用户体验，网站在普通移动硬件上进行测试时，应该努力将总阻塞时间控制在300 毫秒以内。

#### 如何改进 TBT

如需了解如何改进某个特定网站的 TBT，您可以运行一次灯塔性能审计，并留心查看审计建议的各种具体[机会](https://web.dev/lighthouse-performance/#opportunities)。

如需了解改进 TBT 的常见方式（针对任何网站），请参阅以下性能指南：

- [减少第三方代码的影响](https://web.dev/third-party-summary/)
- [减少 JavaScript 执行时间](https://web.dev/bootup-time/)
- [最小化主线程工作](https://web.dev/mainthread-work-breakdown/)
- [保持较低的请求数和较小的传输大小](https://web.dev/resource-summary/)


#### 什么是 CLS？

CLS 测量整个页面生命周期内发生的所有意外布局偏移中最大一连串的布局偏移分数。

每当一个可见元素的位置从一个已渲染帧变更到下一个已渲染帧时，就发生了布局偏移 。

一连串的布局偏移，也叫会话窗口，是指一个或多个快速连续发生的单次布局偏移，每次偏移相隔的时间少于 1 秒，且整个窗口的最大持续时长为 5 秒。

累积布局偏移 (CLS) 是测量视觉稳定性的一个以用户为中心的重要指标，因为该项指标有助于量化用户经历意外布局偏移的频率，较低的 CLS 有助于确保一个页面是令人愉悦的。

**布局偏移分数**

布局偏移分数 = 影响分数 * 距离分数

<img src="../images/post/前端性能指标19.png" />

#### 影响分数

前一帧和当前帧的所有不稳定元素的可见区域集合（占总可视区域的部分）就是当前帧的影响分数

在上图中，有一个元素在一帧中占据了一半的可视区域。接着，在下一帧中，元素下移了可视区域高度的 25%。红色虚线矩形框表示两帧中元素的可见区域集合，在本示例中，该集合占总可视区域的 75%，因此其影响分数为0.75 。

#### 距离分数

距离分数指的是任何不稳定元素在一帧中位移的最大距离（水平或垂直）除以可视区域的最大尺寸维度（宽度或高度，以较大者为准）。

在上方的示例中，最大的可视区域尺寸维度是高度，不稳定元素的位移距离为可视区域高度的 25%，因此距离分数为 0.25。

所以，在这个示例中，影响分数是0.75 ，距离分数是0.25 ，所以布局偏移分数是0.75 * 0.25 = 0.1875 。


#### 测量 CLS 

要在 JavaScript 中测量 CLS，您可以使用[布局不稳定性 API](https://github.com/WICG/layout-instability)。以下示例说明了如何创建一个[`PerformanceObserver`](https://developer.mozilla.org/docs/Web/API/PerformanceObserver)来侦听意外`layout-shift`条目、将条目按会话分组、记录最大会话值，并在最大会话值发生改变时更新记录。


```javascript
let clsValue = 0;
let clsEntries = [];

let sessionValue = 0;
let sessionEntries = [];

new PerformanceObserver((entryList) => {
  for (const entry of entryList.getEntries()) {
    // 只将不带有最近用户输入标志的布局偏移计算在内。
    if (!entry.hadRecentInput) {
      const firstSessionEntry = sessionEntries[0];
      const lastSessionEntry = sessionEntries[sessionEntries.length - 1];

      // 如果条目与上一条目的相隔时间小于 1 秒且
      // 与会话中第一个条目的相隔时间小于 5 秒，那么将条目
      // 包含在当前会话中。否则，开始一个新会话。
      if (sessionValue &&
          entry.startTime - lastSessionEntry.startTime < 1000 &&
          entry.startTime - firstSessionEntry.startTime < 5000) {
        sessionValue += entry.value;
        sessionEntries.push(entry);
      } else {
        sessionValue = entry.value;
        sessionEntries = [entry];
      }

      // 如果当前会话值大于当前 CLS 值，
      // 那么更新 CLS 及其相关条目。
      if (sessionValue > clsValue) {
        clsValue = sessionValue;
        clsEntries = sessionEntries;

        // 将更新值（及其条目）记录在控制台中。
        console.log('CLS:', clsValue, clsEntries)
      }
    }
  }
}).observe({type: 'layout-shift', buffered: true});
```

#### 如何改进 CLS

对于大多数网站来说，您可以通过遵循一些指导原则来避免所有的意外布局偏移：

- **始终在您的图像和视频元素上包含尺寸属性，或者通过使用[CSS 长宽比容器](https://css-tricks.com/aspect-ratio-boxes/)之类的方式预留所需的空间。**这种方法可以确保浏览器能够在加载图像期间在文档中分配正确的空间大小。请注意，您还可以使用[unsized-media 功能策略](https://github.com/w3c/webappsec-feature-policy/blob/master/policies/unsized-media.md)在支持功能策略的浏览器中强制执行此行为。
- **除非是对用户交互做出响应，否则切勿在现有内容的上方插入内容。**这样能够确保发生的任何布局偏移都在预期之内。
- **首选转换动画，而不是触发布局偏移的属性动画。**动画过渡的目标是提供状态与状态之间的上下文连续性。

如需深入了解如何改进 CLS，请参阅[优化 CLS](https://web.dev/optimize-cls/)和[调试布局偏移](https://web.dev/debug-layout-shifts)。











----

## 核心 Web 指标

<img src="../images/post/前端性能指标06.png" />

## Lighthouse 6 个指标

<img src="../images/post/前端性能指标13.png" />

| 项目 | Lighthouse 6 权重 |  Lighthouse 8 权重 |
| --------------- | ------ |
| [First Contentful Paint](https://web.dev/first-contentful-paint/)      | 15% | 10% |
| [Speed Index](https://web.dev/speed-index/)                            | 15% | 10% |
| [Largest Contentful Paint](https://web.dev/lcp/)                       | 25% | 25% |
| [Time to Interactive](https://web.dev/interactive/)                    | 15% | 10% |
| [Total Blocking Time](https://web.dev/lighthouse-total-blocking-time/) | 25% | 30% |
| [Cumulative Layout Shift](https://web.dev/cls/)                        | 5%  | 15% |


#### SI(首屏展现平均值)

[速度指数][11]是页面可见部分显示的平均时间。它以毫秒为单位，并依赖于视图端口的大小。

#### SI怎么计算？

衡量页面加载期间内容的视觉显示速度。Lighthouse 首先在浏览器中捕获页面加载的视频并计算帧之间的视觉进度。Lighthouse 然后使用[Speedline Node.js 模块](https://github.com/paulirish/speedline)生成速度指数分数。

#### SI怎么算好？

（良好）——0 到 3.4 秒

#### 如何优化SI

- 减少渲染阻塞资源

- 减少网站主线程工作








----

## 页面事件
W3C性能工作组在 Navigation Timing API 中定义了一系列页面事件，其中便包括 fetchStart, DOMContentLoaded, Load等事件。

<img src="../images/post/前端性能指标02.png" />

可以如下图通过window.performance.timing属性获取这些事件的具体时间戳，进而对页面性能进行分析。

<img src="../images/post/前端性能指标03.png" />

## TTFB

[TTFB][14] 是从请求资源到收到响应的第一个字节之间的时间。

<img src="../images/post/前端性能指标20.png" />

#### 测量 TTFB

[使用Navigation Timing API](https://developer.mozilla.org/docs/Web/API/Navigation_timing_API)在浏览器中测量[导航请求](https://developer.mozilla.org/docs/Web/API/Request/mode)的 TTFB 。以下示例显示了如何创建一个监听条目并将其记录到控制台的方法：[](https://developer.mozilla.org/docs/Web/API/Navigation_timing_API)[`PerformanceObserver`](https://developer.mozilla.org/docs/Web/API/PerformanceObserver)`navigation`

```javascript
new PerformanceObserver((entryList) => {
  const [pageNav] = entryList.getEntriesByType('navigation');

  console.log(`TTFB: ${pageNav.responseStart}`);
}).observe({
  type: 'navigation',
  buffered: true
});
```

#### 如何优化 TTFB

- [避免多页重定向](https://web.dev/redirects/)。

- [](https://web.dev/uses-rel-preconnect/)预连接到跨域资源[所需的源。](https://web.dev/uses-rel-preconnect/)

- 将您的来源提交到[HSTS 预加载列表](https://hstspreload.org/)以消除 HTTP 到 HTTPS 重定向延迟。

- [使用 HTTP/2](https://web.dev/uses-http2/)或[HTTP/3](https://en.wikipedia.org/wiki/HTTP/3)。

- 在可能和适当的情况下，使用服务器端生成 (SSG) 而非 SSR 进行标记。






#### CSR SSR SSG ISR

client side render

sever side render

static site generator

incremental static regeneration


## 其它的计时器

- [用户计时 API](https://w3c.github.io/user-timing/)
- [长任务 API](https://w3c.github.io/longtasks/)
- [元素计时 API](https://wicg.github.io/element-timing/)
- [导航计时 API](https://w3c.github.io/navigation-timing/)
- [资源计时 API](https://w3c.github.io/resource-timing/)
- [服务器计时 API](https://w3c.github.io/server-timing/)
- [性能计时 API](https://w3c.github.io/performance-timeline)
- [事件计时 API](https://w3c.github.io/event-timing/)

## 定义核心 Web 指标的指标阈值

[这些标准定义的思路和结论][10]

## 推荐工具

- perfume.js  [https://github.com/Zizzamia/perfume.js](https://github.com/Zizzamia/perfume.js)

- web-vitals  [https://github.com/GoogleChrome/web-vitals](https://github.com/GoogleChrome/web-vitals)

- vitals-tools  [https://web.dev/vitals-tools/](https://web.dev/vitals-tools/)

----

[1]: https://w3c.github.io/navigation-timing/
[2]: https://w3c.github.io/paint-timing/
[3]: https://web.dev/fcp/
[4]: https://web.dev/lcp/
[5]: https://web.dev/fid/
[6]: https://web.dev/tti/
[7]: https://web.dev/tbt/
[8]: https://web.dev/evolving-cls/
[9]: https://www.w3.org/webperf/
[10]: https://web.dev/defining-core-web-vitals-thresholds/
[11]: https://web.dev/speed-index/
[12]: https://web.dev/custom-metrics/#long-tasks-api
[13]: https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver
[14]: https://web.dev/ttfb/
[15]: https://w3c.github.io/event-timing/