---
layout: post
filename: 2022-07-30-冒泡和捕获
title: 冒泡和捕获
date: 2022-07-30 20:04:19 +0800
categories: 冒泡和捕获 
tags: 冒泡和捕获
---

冒泡 Bubbling 和 捕获 capturing

[Bubbling and capturing](https://javascript.info/bubbling-and-capturing#capturing)

当一个事件发生时——它发生的最嵌套的元素被标记为“目标元素”（**event.target**）。

- 然后事件从文档根目录向下移动到，调用途中 event.target 分配的处理程序`addEventListener(..., true)` true 是 `{capture: true}` 的简写.

- 然后在目标元素本身上调用处理程序。

- 然后事件从event.target根开始冒泡，调用使用`on<event>`HTML 属性分配的处理程序，并且addEventListener 不使用第三个参数或使用第三个参数 false/{capture:false}。

每个处理程序都可以访问event对象属性：

- **event.target** – 引发事件的最深层元素。
- **event.currentTarget(= this)** – 处理事件的当前元素（具有处理程序的元素）
- **event.eventPhase** – 当前阶段（捕获=1，目标=2，冒泡=3）。

任何事件处理程序都可以通过调用来停止事件`event.stopPropagation()`，但不建议这样做，因为我们不能确定我们不需要它，也许是完全不同的事情。

捕获阶段很少使用，通常我们处理冒泡事件。这背后有一个逻辑。

在现实世界中，当事故发生时，地方当局首先做出反应。他们最了解它发生的区域。如果需要，再上级主管部门。

事件处理程序也是如此。在特定元素上设置处理程序的代码知道有关该元素及其作用的最大细节。一个特定的处理程序`<td>`可能正好适合那个`<td>`，它知道关于它的一切，所以它应该首先获得机会。然后它的直接父级也知道上下文，但稍微少一点，依此类推，直到处理一般概念并运行最后一个的最顶层元素。

冒泡和捕获为“事件委托”奠定了基础——我们将在下一章研究这种极其强大的事件处理模式。