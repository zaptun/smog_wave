---
layout: post
filename: 2022-07-28-JS判断页面滚动方向
title: JS判断页面滚动方向
date: 2022-07-28 00:18:44 +0800
categories: javascript IntersectionObserver
tags: javascript IntersectionObserver
---

### 方法一 scroll

利用 `window.pageYOffset`. [参考文章1][1]

```javascript
let previousScrollPosition = 0;

const isScrollingDown = () => {
    let goingDown = false;

    let scrollPosition = window.pageYOffset;

    if (scrollPosition > previousScrollPosition) {
        goingDown = true;
    }

    previousScrollPosition = scrollPosition;

    return goingDown;
};
```

#### 性能优化

现在，每当用户将页面滚动几个像素时，我们都会调用我们的处理函数。这可能意味着如果我们快速滚动页面，我们的处理函数每秒会被调用多次。这是不必要的，我们不需要那种精确度。

我们可以使用`节流`函数来限制调用次数，即每X时间执行一次操作。一个相关的概念是去抖动，有时人们会混淆它们。([防抖和节流][2])

大概这样

```javascript
const scrollThrottle = throttle(handleScroll, 100);
window.addEventListener("scroll", scrollThrottle);
```
>节流的方法参考 Lodash 或 underscore


### 方法二 Intersection Observer API

[MDN Intersection Observer API](https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API)

JS
```javascript
const state = document.querySelector('.observer__state')
const target = document.querySelector('.observer__target')

const thresholdArray = steps => Array(steps + 1)
 .fill(0)
 .map((_, index) => index / steps || 0)

let previousY = 0
let previousRatio = 0

const handleIntersect = entries => {
  entries.forEach(entry => {
    const currentY = entry.boundingClientRect.y
    const currentRatio = entry.intersectionRatio
    const isIntersecting = entry.isIntersecting

    // Scrolling down/up
    if (currentY < previousY) {
      if (currentRatio > previousRatio && isIntersecting) {
        state.textContent ="Scrolling down enter"
      } else {
        state.textContent ="Scrolling down leave"
      }
    } else if (currentY > previousY && isIntersecting) {
      if (currentRatio < previousRatio) {
        state.textContent ="Scrolling up leave"
      } else {
        state.textContent ="Scrolling up enter"
      }
    }

    previousY = currentY
    previousRatio = currentRatio
  })
}

const observer = new IntersectionObserver(handleIntersect, {
  threshold: thresholdArray(20),
})

observer.observe(target)
```
css
```css
html,
body {
  margin: 0;
}

.observer__target {
  position: relative;
  width: 100%;
  height: 350px;
  margin: 1500px 0;
  background: rebeccapurple;
}

.observer__state {
  position: fixed;
  top: 1em;
  left: 1em;
  color: #111;
  font: 400 1.125em/1.5 sans-serif;
  background: #fff;
}
```

html
```htm
<div class="observer__target"></div>
<span class="observer__state"></span>
```


----

### 参考

[参考文章1](https://www.roboleary.net/frontend/2022/04/13/detect-scroll-direction-vanilla-javascript.html#:~:text=In%20our%20JavaScript%20code%2C%20we%20will%20add%20a,with%20a%20green%20background%2C%20as%20below%20in%20screenshot)


<!-- Reference Links -->

[1]:https://www.roboleary.net/frontend/2022/04/13/detect-scroll-direction-vanilla-javascript.html#:~:text=In%20our%20JavaScript%20code%2C%20we%20will%20add%20a,with%20a%20green%20background%2C%20as%20below%20in%20screenshot

[2]:https://redd.one/blog/debounce-vs-throttle