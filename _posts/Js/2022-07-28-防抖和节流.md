---
layout: post
filename: 2022-07-28-防抖和节流
title: 防抖和节流
date: 2022-07-28 19:35:36 +0800
categories: 防抖 节流
tags: 防抖 节流
---

## 防抖 Debounce

一个未声明的函数会在自上次调用以来经过N段时间后被调用。它对看似已解决的状态作出反应，并暗示事件和处理程序函数调用之间存在延迟。

简单的实现防抖

```javascript
function debounce(func, duration) {
  let timeout
  return function (...args) {
    const effect = () => {
      timeout = null
      return func.apply(this, args)
    }
    clearTimeout(timeout)
    timeout = setTimeout(effect, duration)
  }
}
```

**什么时候使用debounce?**

使用debounce来对经常发生的事情做出最终的反应。

当你不需要中间状态而希望响应事件的结束状态时，Debounce很有用。也就是说，当使用debounce时，你需要考虑到事件和对它的回应之间不可避免的延迟。

**dedeclare函数的常见用例:**
* 异步搜索建议
* 在服务器上批量更新


## 节流 Throttle

一个节流函数每N个时间被调用一次。在指定的时间间隔内的任何附加函数调用将被忽略。

简单的实现节流

```javascript
function throttle(func, duration) {
  let shouldWait = false
  return function (...args) {
    if (!shouldWait) {
      func.apply(this, args)
      shouldWait = true
      setTimeout(function () {
        shouldWait = false
      }, duration)
    }
  }
}
```

**什么时候使用节流?**

使用油门来持续地对频繁的事件做出反应。

这种技术确保函数在给定的时间间隔内执行一致。由于throttle被绑定到一个时间框架，因此分派的事件处理程序应该准备好接受事件的中间状态。

**节流函数的常见用例:**
* 任何一致的UI更新后的窗口大小调整
* 对服务器或客户端进行性能要求较高的操作



## 项目中使用封装

原生封装的方法，参考 [underscore源码 https://underscorejs.org/underscore-esm.js][1]

### debounce方法
```javascript
// When a sequence of calls of the returned function ends, the argument
// function is triggered. The end of a sequence is defined by the `wait`
// parameter. If `immediate` is passed, the argument function will be
// triggered at the beginning of the sequence instead of at the end.
function debounce(func, wait, immediate) {
  var timeout, previous, args, result, context;

  var later = function() {
    var passed = now() - previous;
    if (wait > passed) {
      timeout = setTimeout(later, wait - passed);
    } else {
      timeout = null;
      if (!immediate) result = func.apply(context, args);
      // This check is needed because `func` can recursively invoke `debounced`.
      if (!timeout) args = context = null;
    }
  };

  var debounced = restArguments(function(_args) {
    context = this;
    args = _args;
    previous = now();
    if (!timeout) {
      timeout = setTimeout(later, wait);
      if (immediate) result = func.apply(context, args);
    }
    return result;
  });

  debounced.cancel = function() {
    clearTimeout(timeout);
    timeout = args = context = null;
  };

  return debounced;
}
```


### throttle方法

```javascript
// Returns a function, that, when invoked, will only be triggered at most once
// during a given window of time. Normally, the throttled function will run
// as much as it can, without ever going more than once per `wait` duration;
// but if you'd like to disable the execution on the leading edge, pass
// `{leading: false}`. To disable execution on the trailing edge, ditto.
function throttle(func, wait, options) {
  var timeout, context, args, result;
  var previous = 0;
  if (!options) options = {};

  var later = function() {
    previous = options.leading === false ? 0 : now();
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) context = args = null;
  };

  var throttled = function() {
    var _now = now();
    if (!previous && options.leading === false) previous = _now;
    var remaining = wait - (_now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = _now;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };

  throttled.cancel = function() {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };

  return throttled;
}
```



### 参考文章

[参考文章 https://redd.one/blog/debounce-vs-throttle](https://redd.one/blog/debounce-vs-throttle)

[1]: https://underscorejs.org/underscore-esm.js