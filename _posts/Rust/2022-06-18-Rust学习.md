---
layout: post
filename: 2022-06-18-Rust学习
title: Rust学习
date: 2022-06-18 10:28:01 +0800
categories: Rust
tags: Rust
---



## 介绍

Rust 语言是一种高效、可靠的通用高级语言。其高效不仅限于开发效率，它的执行效率也是令人称赞的，是一种少有的兼顾开发效率和执行效率的语言。

Rust 语言由 Mozilla 开发，最早发布于 2014 年 9 月。Rust 的编译器是在 MIT License 和 Apache License 2.0 双重协议声明下的免费开源软件。截至目前( 2020 年 1 月)最新的编译器版本是 1.41.0。

Rust 官方在线工具: https://play.rust-lang.org/。



## Rust语言的特点

- **高性能** - Rust 速度惊人且内存利用率极高。由于没有运行时和垃圾回收，它能够胜任对性能要求特别高的服务，可以在嵌入式设备上运行，还能轻松和其他语言集成。
- **可靠性** - Rust 丰富的类型系统和所有权模型保证了内存安全和线程安全，让您在编译期就能够消除各种各样的错误。
- **生产力** - Rust 拥有出色的文档、友好的编译器和清晰的错误提示信息， 还集成了一流的工具 —— 包管理器和构建工具， 智能地自动补全和类型检验的多编辑器支持， 以及自动格式化代码等等。



## Rust的应用

Rust 语言可以用于开发：

- **传统命令行程序** - Rust 编译器可以直接生成目标可执行程序，不需要任何解释程序。
- **Web 应用** - Rust 可以被编译成 WebAssembly，WebAssembly 是一种 JavaScript 的高效替代品。
- **网络服务器** - Rust 用极低的资源消耗做到安全高效，且具备很强的大规模并发处理能力，十分适合开发普通或极端的服务器程序。
- **嵌入式设备** - Rust 同时具有JavaScript 一般的高效开发语法和 C 语言的执行效率，支持底层平台的开发。

## Rust 程序编译

Rust 语言代码文件后缀名为 **.rs**, 如 **runoob.rs**。

实例：runoob.rs 文件

```rust
fn main() {
  println!("Hello World!");
}
```

[运行实例 »](https://www.runoob.com/try/runcode.php?filename=HelloWorld&type=rust)

使用 **rustc** 命令编译 runoob.rs 文件：

```shell
$ rustc runoob.rs   # 编译 runoob.rs 文件
```

编译后会生成 **runoob** 可执行文件：

```shell
$ ./runoob    # 执行 runoob
Hello World!
```

## Rust 环境搭建

Rust 支持很多的集成开发环境（IDE）或开发专用的文本编辑器。

官方网站公布支持的工具如下（https://www.rust-lang.org/zh-CN/tools）：

![image](../images/post/rust01.png)

本教程将使用 Visual Studio Code 作为我们的开发环境（Eclipse 有专用于 Rust 开发的版本，对于初学者也是不错的选择）。

注意：IntelliJ IDEA 安装插件之后难以调试，所以推荐习惯使用 IDEA 的开发者使用 CLion，但 CLion 不是免费的。

### 搭建 Visual Studio Code 开发环境

首先，需要安装最新版的 Rust 编译工具和 Visual Studio Code。

Rust 编译工具：https://www.rust-lang.org/zh-CN/tools/install

```shell
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

>可以用Homebrew search rust，直接安装，不过还是推荐rustup，因为homebrew更新不是很快

Visual Studio Code：https://code.visualstudio.com/Download

Rust 的编译工具依赖 C 语言的编译工具，这意味着你的电脑上至少已经存在一个 C 语言的编译环境。如果你使用的是 Linux 系统，往往已经具备了 GCC 或 clang。如果你使用的是 macOS，需要安装 Xcode。如果你是用的是 Windows 操作系统，你需要安装 Visual Studio 2013 或以上的环境（需要 C/C++ 支持）以使用 MSVC 或安装 MinGW + GCC 编译环境（Cygwin 还没有测试）。

### 验证安装

```shell
rustc -V        # 注意的大写的 V
cargo -V

# 查看已安装和可用的工具链
rustup show

# 你可以查看默认工具链并根据需要进行更改
rustup install stable-aarch64-apple-darwin
rustup default stable-aarch64-apple-darwin

# 切换到每日更新版工具链
ustup default nightly

# 查看 Rust 的编译器和包管理器的完整路径
rustup which rustc
rustup which cargo

# 要检查是否有新的 Rust 工具链可用
rustup check

# 可以安装多个工具链
rustup install nightly
rustup install stable
rustup install 1.7
```



## 创建Demo工程

```shell
#构建一个名叫 greeting 的 Rust 工程目录
cargo new greeting

#运行demo
cd ./greeting 
cargo build 
cargo run
```

![image](../images/post/rust02.png)

系统在创建工程时会生成一个 Hello, world 源程序 main.rs，这时会被编译并运行



## Cargo 教程

### Cargo 是什么

Cargo 是 Rust 的构建系统和包管理器。

Rust 开发者常用 Cargo 来管理 Rust 工程和获取工程所依赖的库。在上个教程中我们曾使用 cargo new greeting 命令创建了一个名为 greeting 的工程，Cargo 新建了一个名为 greeting 的文件夹并在里面部署了一个 Rust 工程最典型的文件结构。这个 greeting 文件夹就是工程本身。

### Cargo 功能

Cargo 除了创建工程以外还具备构建（build）工程、运行（run）工程等一系列功能，构建和运行分别对应以下命令：

```shell
cargo build 
cargo run 
```

Cargo 还具有获取包、打包、高级构建等功能，详细使用方法参见 Cargo 命令。



### 在 VSCode 中配置Debug Rust工程

Cargo 是一个不错的构建工具，如果使 VSCode 与它相配合那么 VSCode 将会是一个十分便捷的开发环境。



在上一章中我们建立了 greeting 工程，现在我们用 VSCode 打开 **greeting** 文件夹（**注意不是 runoob-greeting**）。

打开 greeting 之后，在里面新建一个新的文件夹 **.vscode** （注意 vscode 前面的点，如果有这个文件夹就不需要新建了）。在新建的 .vscode 文件夹里新建两个文件 tasks.json 和 launch.json，文件内容如下：



### tasks.json 文件

```json
{ 
    "version": "2.0.0", 
    "tasks": [ 
        { 
            "label": "build", 
            "type": "shell", 
            "command":"cargo", 
            "args": ["build"] 
        } 
    ] 
}
```

### launch.json 文件

- 适用在 Windows 系统上

```json
{ 
    "version": "0.2.0", 
    "configurations": [ 
        { 
            "name": "(Windows) 启动", 
            "preLaunchTask": "build", 
            "type": "cppvsdbg", 
            "request": "launch", 
            "program": "${workspaceFolder}/target/debug/${workspaceFolderBasename}.exe", 
            "args": [], 
            "stopAtEntry": false, 
            "cwd": "${workspaceFolder}", 
            "environment": [], 
            "externalConsole": false 
        }, 
        { 
            "name": "(gdb) 启动", 
            "type": "cppdbg", 
            "request": "launch", 
            "program": "${workspaceFolder}/target/debug/${workspaceFolderBasename}.exe", 
            "args": [], 
            "stopAtEntry": false, 
            "cwd": "${workspaceFolder}", 
            "environment": [], 
            "externalConsole": false, 
            "MIMode": "gdb", 
            "miDebuggerPath": "这里填GDB所在的目录", 
            "setupCommands": [ 
                { 
                    "description": "为 gdb 启用整齐打印", 
                    "text": "-enable-pretty-printing", 
                    "ignoreFailures": true 
                } 
            ] 
        } 
    ] 
}
```



- 适用在 Linux 系统上

```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Debug",
            "type": "gdb",
            "preLaunchTask": "build",
            "request": "launch",
            "target": "${workspaceFolder}/target/debug/${workspaceFolderBasename}",
            "cwd": "${workspaceFolder}"
        }
    ]
}
```



- 适用在 Mac OS 系统上

```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "(lldb) 启动",
            "type": "cppdbg",
            "preLaunchTask": "build",
            "request": "launch",
            "program": "${workspaceFolder}/target/debug/${workspaceFolderBasename}",
            "args": [],
            "stopAtEntry": false,
            "cwd": "${workspaceFolder}",
            "environment": [],
            "externalConsole": false,
            "MIMode": "lldb"
        }
    ]
}
```

然后点击 VSCode 左栏的 "运行"。

如果你使用的是 MSVC 选择 "(Windows) 启动"。

如果使用的是 MinGW 且安装了 GDB 选择"(gdb)启动"，gdb 启动前请注意填写 launch.json 中的 "miDebuggerPath"。

![image](../images/post/rust03.png)

程序就会开始调试运行了。运行输出将出现在"调试控制台"中：

![image](../images/post/rust04.png)

调试程序的方法与其它环境相似，只需要在行号的左侧点击红点就可以设置断点，在运行中遇到断点会暂停，以供开发者监视实时变量的值。

![image](../images/post/rust05.png)



几个 cargo 的重要子命令:

- cargo clippy: 类似eslint，lint工具检查代码可以优化的地方
- cargo fmt: 类似go fmt，代码格式化
- cargo tree: 查看第三方库的版本和依赖关系
- cargo bench: 运行benchmark(基准测试,性能测试)
- cargo udeps(第三方): 检查项目中未使用的依赖

另外 **cargo build/run --release** 使用 release 编译会比默认的 debug 编译性能提升 10 倍以上，但是 release 缺点是编译速度较慢，而且不会显示 panic backtrace 的具体行号;

## 添加依赖库

可以在 [crates.io][1] 网站找所有类别的库。在 Rust 中，我们通常把包称作 "crates"。

比如要添加一个 ferris-says 的库。

在 `Cargo.toml` 文件中添加以下信息：

```toml
[dependencies]
ferris-says = "0.2"
```
接着运行: cargo build 之后 Cargo 就会安装该依赖.

运行此命令会创建一个新文件 Cargo.lock，该文件记录了本地所用依赖库的精确版本。

使用依赖库，在文件中添加如下代码：
```rust
use ferris_says::say;
```
这样我们就可以使用 ferris-says crate 中导出的 say 函数了。



## Rust 输出到命令行

在正式学习 Rust 语言以前，我们需要先学会怎样输出一段文字到命令行，这几乎是学习每一门语言之前必备的技能，因为输出到命令行几乎是语言学习阶段程序表达结果的唯一方式。

在之前的 Hello, World 程序中大概已经告诉了大家输出字符串的方式，但并不全面，大家可能很疑惑为什么 println!( "Hello World") 中的 println 后面还有一个 **!** 符号，难道 Rust 函数之后都要加一个感叹号？显然并不是这样。println 不是一个函数，而是一个宏规则。这里不需要更深刻的挖掘宏规则是什么，后面的章节中会专门介绍，并不影响接下来的一段学习。

Rust 输出文字的方式主要有两种：**println!()** 和 **print!()**。这两个"函数"都是向命令行输出字符串的方法，区别仅在于前者会在输出的最后附加输出一个换行符。当用这两个"函数"输出信息的时候，第一个参数是格式字符串，后面是一串可变参数，对应着格式字符串中的"占位符"，这一点与 C 语言中的 printf 函数很相似。但是，Rust 中格式字符串中的占位符不是 **"% + 字母"** 的形式，而是一对 **{}**。

```rust
fn main() {
    let a = 12;
    println!("a is {}", a);
}
```

使用 **rustc** 命令编译 runoob.rs 文件：

```shell
$ rustc runoob.rs   # 编译 runoob.rs 文件
```

编译后会生成 **runoob** 可执行文件：

```shell
$ ./runoob    # 执行 runoob
```

以上程序的输出结果是：

```rust
a is 12 
```

如果我想把 a 输出两遍，那岂不是要写成：

```rust
println!("a is {}, a again is {}", a, a); 
```

其实有更好的写法：

```rust
println!("a is {0}, a again is {0}", a); 
```
{% raw %}
在 **{}** 之间可以放一个数字，它将把之后的可变参数当作一个数组来访问，下标从 0 开始。

如果要输出 **{** 或 **}** 怎么办呢？格式字符串中通过 **{{** 和 **}}** 分别转义代表 { 和 }。但是其他常用转义字符与 C 语言里的转义字符一样，都是反斜杠开头的形式。

```rust
fn main() { 
    println!("{{}}"); 
} 
```

以上程序的输出结果是：

```shell
{}
```
{% endraw %}

# Rust 基础语法

变量，基本类型，函数，注释和控制流，这些几乎是每种编程语言都具有的编程概念。

这些基础概念将存在于每个 Rust 程序中，及早学习它们将使你以最快的速度学习 Rust 的使用。

## 变量

首先必须说明，Rust 是强类型语言，但具有自动判断变量类型的能力。这很容易让人与弱类型语言产生混淆。

如果要声明变量，需要使用 **let** 关键字。例如：

```
let a = 123;
```

只学习过 JavaScript 的开发者对这句话很敏感，只学习过 C 语言的开发者对这句话很不理解。

在这句声明语句之后，以下三行代码都是被禁止的：

```
a = "abc";
a = 4.56; 
a = 456;
```

第一行的错误在于当声明 a 是 123 以后，a 就被确定为整型数字，不能把字符串类型的值赋给它。

第二行的错误在于自动转换数字精度有损失，Rust 语言不允许精度有损失的自动数据类型转换。

第三行的错误在于 a 不是个可变变量。

前两种错误很容易理解，但第三个是什么意思？难道 a 不是个变量吗？

这就牵扯到了 Rust 语言为了高并发安全而做的设计：在语言层面尽量少的让变量的值可以改变。所以 a 的值不可变。但这不意味着 a 不是"变量"（英文中的 variable），官方文档称 a 这种变量为"不可变变量"。

如果我们编写的程序的一部分在假设值永远不会改变的情况下运行，而我们代码的另一部分在改变该值，那么代码的第一部分可能就不会按照设计的意图去运转。由于这种原因造成的错误很难在事后找到。这是 Rust 语言设计这种机制的原因。

当然，使变量变得"可变"（mutable）只需一个 **mut** 关键字。

```rust
let mut a = 123;
a = 456;
```

这个程序是正确的。

## 常量与不可变变量的区别

既然不可变变量是不可变的，那不就是常量吗？为什么叫变量？

变量和常量还是有区别的。在 Rust 中，以下程序是合法的：

```rust
let a = 123;   // 可以编译，但可能有警告，因为该变量没有被使用
let a = 456;
```

但是如果 a 是常量就不合法：

```rust
const a: i32 = 123;
let a = 456;
```

变量的值可以"重新绑定"，但在"重新绑定"以前不能私自被改变，这样可以确保在每一次"绑定"之后的区域里编译器可以充分的推理程序逻辑。 虽然 Rust 有自动判断类型的功能，但有些情况下声明类型更加方便：

```rust
let a: u64 = 123;
```

这里声明了 a 为无符号 64 位整型变量，如果没有声明类型，a 将自动被判断为有符号 32 位整型变量，这对于 a 的取值范围有很大的影响。

## 重影（Shadowing）

重影的概念与其他面向对象语言里的"重写"（Override）或"重载"（Overload）是不一样的。重影就是刚才讲述的所谓"重新绑定"，之所以加引号就是为了在没有介绍这个概念的时候代替一下概念。

重影就是指变量的名称可以被重新使用的机制：

```rust
fn main() {
    let x = 5;
    let x = x + 1;
    let x = x * 2;
    println!("The value of x is: {}", x);
}
```

这段程序的运行结果：

```rust
The value of x is: 12
```

重影与可变变量的赋值不是一个概念，重影是指用同一个名字重新代表另一个变量实体，其类型、可变属性和值都可以变化。但可变变量赋值仅能发生值的变化。

```rust
let mut s = "123";
s = s.len();
```

这段程序会出错：不能给字符串变量赋整型值。



# Rust 数据类型

Rust 语言中的基础数据类型有以下几种。

## 整数型（Integer）

整数型简称整型，按照比特位长度和有无符号分为一下种类：

| 位长度  | 有符号 | 无符号 |
| :------ | :----- | :----- |
| 8-bit   | i8     | u8     |
| 16-bit  | i16    | u16    |
| 32-bit  | i32    | u32    |
| 64-bit  | i64    | u64    |
| 128-bit | i128   | u128   |
| arch    | isize  | usize  |

isize 和 usize 两种整数类型是用来衡量数据大小的，它们的位长度取决于所运行的目标平台，如果是 32 位架构的处理器将使用 32 位位长度整型。

整数的表述方法有以下几种：

| 进制                 | 例          |
| :------------------- | :---------- |
| 十进制               | 98_222      |
| 十六进制             | 0xff        |
| 八进制               | 0o77        |
| 二进制               | 0b1111_0000 |
| 字节(只能表示 u8 型) | b'A'        |

很显然，有的整数中间存在一个下划线，这种设计可以让人们在输入一个很大的数字时更容易判断数字的值大概是多少。

## 浮点数型（Floating-Point）

Rust 与其它语言一样支持 32 位浮点数（f32）和 64 位浮点数（f64）。默认情况下，64.0 将表示 64 位浮点数，因为现代计算机处理器对两种浮点数计算的速度几乎相同，但 64 位浮点数精度更高。

```rust
fn main() {
    let x = 2.0; // f64
    let y: f32 = 3.0; // f32
}
```

## 数学运算

用一段程序反应数学运算：

```rust
fn main() {
    let sum = 5 + 10; // 加
    let difference = 95.5 - 4.3; // 减
    let product = 4 * 30; // 乘
    let quotient = 56.7 / 32.2; // 除
    let remainder = 43 % 5; // 求余
}
```

许多运算符号之后加上 = 号是自运算的意思，例如：

**sum += 1** 等同于 **sum = sum + 1**。

**注意：**Rust 不支持 **++** 和 **--**，因为这两个运算符出现在变量的前后会影响代码可读性，减弱了开发者对变量改变的意识能力。

## 布尔型

布尔型用 bool 表示，值只能为 true 或 false。

## 字符型

字符型用 char 表示。

Rust的 char 类型大小为 4 个字节，代表 Unicode标量值，这意味着它可以支持中文，日文和韩文字符等非英文字符甚至表情符号和零宽度空格在 Rust 中都是有效的 char 值。

Unicode 值的范围从 U+0000 到 U+D7FF 和 U+E000 到 U+10FFFF （包括两端）。 但是，"字符"这个概念并不存在于 Unicode 中，因此您对"字符"是什么的直觉可能与Rust中的字符概念不匹配。所以一般推荐使用字符串储存 UTF-8 文字（非英文字符尽可能地出现在字符串中）。

**注意：**由于中文文字编码有两种（GBK 和 UTF-8），所以编程中使用中文字符串有可能导致乱码的出现，这是因为源程序与命令行的文字编码不一致，所以在 Rust 中字符串和字符都必须使用 UTF-8 编码，否则编译器会报错。

## 复合类型

元组用一对 **( )** 包括的一组数据，可以包含不同种类的数据：

```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);
// tup.0 等于 500
// tup.1 等于 6.4
// tup.2 等于 1
let (x, y, z) = tup;
// y 等于 6.4
```

数组用一对 **[ ]** 包括的同类型数据。

```rust
let a = [1, 2, 3, 4, 5];
// a 是一个长度为 5 的整型数组

let b = ["January", "February", "March"];
// b 是一个长度为 3 的字符串数组

let c: [i32; 5] = [1, 2, 3, 4, 5];
// c 是一个长度为 5 的 i32 数组

let d = [3; 5];
// 等同于 let d = [3, 3, 3, 3, 3];

let first = a[0];
let second = a[1];
// 数组访问

a[0] = 123; // 错误：数组 a 不可变
let mut a = [1, 2, 3];
a[0] = 4; // 正确
```

# Rust 注释

Rust 中的注释方式与其它语言（C、Java）一样，支持两种注释方式：

```rust
// 这是第一种注释方式

/* 这是第二种注释方式 */

/*
 * 多行注释
 * 多行注释
 * 多行注释
 */
```

### 用于说明文档的注释

在 Rust 中使用 **//** 可以使其之后到第一个换行符的内容变成注释。

在这种规则下，三个反斜杠 **///** 依然是合法的注释开始。所以 Rust 可以用 **///** 作为说明文档注释的开头：

```rust
/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let x = add(1, 2);
///
/// ```

fn add(a: i32, b: i32) -> i32 {
    return a + b;
}
   
fn main() {
    println!("{}",add(2,3));
}
```

程序中的函数 add 就会拥有一段优雅的注释，并可以显示在 IDE 中：

![image](../images/post/rust06.png)











----



# 参考链接

- Rust 官方网站：https://www.rust-lang.org/zh-CN
- Rust 官方文档：https://doc.rust-lang.org/
- Rust Play：https://play.rust-lang.org/
- Visual Studio Code：https://code.visualstudio.com/
- Rust 教程: https://www.runoob.com/rust/rust-ownership.html
- 几张图让你看懂WebAssembly: https://www.jianshu.com/p/bff8aa23fe4d

[1]:https://crates.io
