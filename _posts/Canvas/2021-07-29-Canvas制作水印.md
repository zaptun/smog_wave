---
layout: post
filename: 2021-07-29-Canvas制作水印
title: Canvas制作水印
date: 2021-07-29 14:48:46 +0800
categories: Canvas
tags: 水印 Canvas
---



项目需要做全站水印，所以思考做一个库，解决通问题；

## 大概思路

1. 先用canvas绘制生成水印的image的base64数据或者blobUrl；
2. 生成**shadowDOM**，覆盖全屏body，设置background为第一步生成的水印图片；
3. 用**MutationObserver**监听变化，防止有人删除水印；

## 开始编写

### 1. canvas绘制文字水印

第一个问题：

#### canvas绘制文字换行

```javascript
// 创建canvas
const canvas = document.createElement("canvas");
const ctx = canvas.getContext("2d");
const canvasWidth = width;
const canvasHeight = height;
canvas.setAttribute("width", `${canvasWidth}px`);
canvas.setAttribute("height", `${canvasHeight}px`);

// 获取文本的最大宽度，利用measureText方法
const texts = Array.isArray(text) ? text : [text];
const widths = texts.map(item => ctx.measureText(item).width);
const maxWidth = Math.max(...widths);

//转换字体大小为数字
const markSize = Number(fontSize);

// 文案宽度大于画板宽度，文字缩小一般
if (maxWidth > width) {
  ctx.font = getFont(`${markSize / 2}px`);
}

// 获取行高配置，如果没有用字体大小加5
const marklineHeight = lineHeight ? lineHeight : markSize + 5;

// 计算水印在y轴上的初始位置
let initY = (canvasHeight - (markFontSize * texts.length + (texts.length - 1) * 5)) / 2;
initY = initY < 0 ? 0 : initY;

//绘制文字
for (let i = 0; i < texts.length; i++) {
  ctx.fillText(texts[i], canvasWidth / 2, initY + marklineHeight * i);
}
```

第二问题：

#### canvas 图片、文字在高清屏模糊问题

下图是透明度为1，颜色red效果，整体呈现模糊，颜色不够深等问题；

<img src="../images/post/Canvas制作水印01.png" alt="Canvas制作水印01" style="zoom:50%;" />

原因：渲染时css中的像素（逻辑像素）候和实际像素（物理像素）的比值。比如说：iPhone 4S它的devicePixelRatio 属性的值是2，那就是100px逻辑像素等于200px的设备实际像素，也就是我们的图像在高分屏上被放大了。解决这额个问题的方法就是，创建的图片的时候根据devicePixelRatio 放大数倍（比原照片更大的新的一张图片）然后再用css再把它缩小到原来的样子。因此缩小后的图片不会超过自己原来的尺寸并且不会再模糊。这样一来问题就解决了（当然这又带来了一个新的问题，你要根据不同的DPI设备获取不同的图片）

思路就是根据`devicePixelRatio(dpr)` 来等比放大绘制，展示的时候再缩小回来；

第三问题：

#### 不同的浏览器绘制兼容

<img src="../images/post/Canvas制作水印02.png" alt="Canvas制作水印02" style="zoom:50%;" />

为什么会这样？在Chrome 和 safari 6中两者的devicePixelRatio(*dpr*)都是一样的，但是两者对于canvas的绘制方法不同；解决方法就是一个新的概念 `backing store`

>backing store是什么？
>
>在你用canvas画任何图像的时候，实质上浏览器都会将这些图形存储在canvas的底层存储层，这个我们就称之为backing store 。当浏览器开始用canvas画图的时候都是从backing store 中拿数据再进行绘制。这就意味着有了这个属性我们可以知道backing store的尺寸和canvas尺寸的关系。

代码中我们用`webkitBackingStorePixelRatio`来获取backing store的尺寸，目前 Mozilla、Opera 、 Microsoft没有这个属性。

为了简单起见，比方说我们有个canvas他的宽度是200px并且它的webkitBackingStorePixelRatio的值是2.因此底层的backing store尺寸就是400px。要注意的是不同的浏览器在不同的设备上webkitBackingStorePixelRatio的值都不同，不一定是2。

<img src="../images/post/Canvas制作水印03.png" alt="img" style="zoom:85%;" />

当浏览器开始渲染canvas，它先被比例缩小根据他的逻辑像素200px（之前的假设）。然后再根据devicePixelRatio再放大，假设devicePixelRatio 也是2和webkitBackingStoreRatio相同，那就是400px。（devicePixelRatio 也不一定是2，三星Nexus 7就是1.325），可能你还会有疑惑这个过程，看一下下图：

![preview](../images/post/Canvas制作水印04.jpg)

**实施差异**

比如说在Macbook Pro Rentina 高分屏上，Safari 6的devicePixelRatio 和 webkitBackingStoreRatio的值分别是2和2。但是chrome是2和1。这意味着如果你在canvas上画图Safari将会自动的把你的图片尺寸变成两倍存储在backing store里，

然后又缩小到逻辑像素然后通过devicePixelRatio又放大和backing store里的尺寸一样。但在chrome中图像直接根据逻辑像素尺寸存到backing store中，但在之后devicePixelRatio作用后图片将会被放大因此变模糊了。也就是在默认的chrome中图像渲染会变得模糊相较于Safari 6，因为我们的图片被不同的尺寸写进backing store ，然后通过devicePixelRatio进行了放大。

**解决办法：**

> 通过devicePixelRatio和 webkitBackingStorePixelRatio的比值去放大canvas的height和width然后再用css把他们缩小到原来的逻辑像素尺寸，代码如下：

```javascript
const devicePixelRatio = window.devicePixelRatio || 1;
const backingStoreRatio = context.webkitBackingStorePixelRatio ||
                    context.mozBackingStorePixelRatio ||
                    context.msBackingStorePixelRatio ||
                    context.oBackingStorePixelRatio ||
                    context.backingStorePixelRatio || 1;
const ratio = devicePixelRatio / backingStoreRatio;

var oldWidth = canvas.width;
var oldHeight = canvas.height;
//渲染放大
canvas.width = oldWidth * ratio;
canvas.height = oldHeight * ratio;
//实际size
canvas.style.width = oldWidth + 'px';
canvas.style.height = oldHeight + 'px';

//将画布缩放，将图像放大两倍画到画布上
context.scale(ratio,ratio);
```
<img src="../images/post/Canvas制作水印05.png" style="zoom:90%;"  />


第四个问题：

#### 旋转问题

可以用 transform，[参考文章1](https://www.twle.cn/l/yufei/canvas/canvas-basic-geometric-transform.html) [参考文章2](https://www.cnblogs.com/suyuanli/p/8279244.html)





第五个问题：

#### 文字渲染宽度measureText不准确

正常的方法：利用measureText来获取

```javascript
ctx.measureText(item).width
```

用了一个性能不太好的方案，见一个div，完全透明，移动到页面外，获取这个dom的宽度

```javascript
/**
 * 获取文字渲染后宽度
 *
 * @param data - Array<string> | String
 * @returns result - Array<number>
 */
function getWordWidth(data: string[] | string): Array<number> {
  const result = [];
  const wrap = document.createElement("div");
  wrap.setAttribute("style", `font-size:${fontSize}px;position:fixed;opacity:0;top:-1000%;`);
  document.body.appendChild(wrap);
  if (Array.isArray(data)) {
    data.map(item => {
      rendWord(item);
    });
  } else {
    rendWord(data);
  }
  function rendWord(txt: string): void {
    const word = document.createElement("span");
    word.innerHTML = txt;
    wrap.append(word);
    result.push(word.offsetWidth);
  }
  document.body.removeChild(wrap);
  // console.log("result=>", result);
  return result;
}
```



### 2. 绘制图片水印

第一个问题：

#### 跨域图片的导出问题

如果是一个跨域图片，你可以把它绘制到 canvas 中，但是不能做任何有关导出数据的操作（`toDataURL`，`toBlob`，`getImageData` ），因为 canvas 认为它自己是被污染（tainted）的。（本地上传的图片不存在这个问题）

[MDN说明文档](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image)

处理办法

首先，你必须有一个可以对图片响应正确 `Access-Control-Allow-Origin` 响应头的服务器。服务器能允许跨域访问图片。然后客户端如下代码：

```javascript
var img = new Image();
img.setAttribute('crossOrigin', 'anonymous');
img.onload = function() {
    var canvas1 = document.createElement("canvas");
    canvas1.width = this.width;
    canvas1.height = this.height;
    var ctx = canvas.getContext('2d');
    ctx.drawImage(this, 0, 0);
    var dataURL = canvas.toDataURL({format: "png"});
};
img.src = url;
```

> 相关的工具库：[fabric js官网](http://fabricjs.com/fabric-intro-part-1#canvas)
>
> 有的文章有说用这个库可以解决，具体的这个库我还没尝试，底层实现的原理也没去研究，大概的使用方式如下：

```javascript
function getBase64FromImageUrl(URL) {
    var canvas  = new fabric.Canvas('c');
    var img = new Image();
    img.onload = function() {
        var canvas1 = document.createElement("canvas");
        canvas1.width = this.width;
        canvas1.height = this.height;
        var ctx = canvas.getContext('2d');
        ctx.drawImage(this, 0, 0);
        var dataURL = canvas.toDataURL({format: "png"});
    };
    img.src = URL;
}
```



参考

https://zhuanlan.zhihu.com/p/26853035

### 3. shadowDOM渲染水印背景图片

#### 什么是shadow DOM

为了Web components封装提供的特殊DOM类型，它允许在常规的 DOM 树中隐藏自定义的DOM节点；

[MDN shadowDom文档](https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_shadow_DOM)

<img src="../images/post/Canvas制作水印06.png" alt="img" style="zoom:60%;" />



- Shadow host：一个常规 DOM节点，Shadow DOM 会被附加到这个节点上。
- Shadow tree：Shadow DOM内部的DOM树。
- Shadow boundary：Shadow DOM结束的地方，也是常规 DOM开始的地方。
- Shadow root: Shadow tree的根节点。

Shadow DOM 内部的元素始终不会影响到它外部的元素。使用的实际场景比如：video,  input等等等；你所能看到的只是一个 `<video>` 标签，实际上，在它的 Shadow DOM 中，包含来一系列的按钮和其他控制器。

下图就是一个video的shadow dom例子：

<img src="../images/post/Canvas制作水印07.png" alt="Canvas制作水印07" style="zoom:50%;" />

> **备注：** Firefox（从版本 63 开始），Chrome，Opera 和 Safari 默认支持 Shadow DOM。基于 Chromium 的新 Edge 也支持 Shadow DOM；而旧 Edge 未能支持此特性。

#### 使用方法

##### 1.给shadow host绑定shadow root

`elementRef.attachShadow` 方法会将一个 shadow root 附加到指定元素上，接受对象配置**shadowRootInit**，

shadowRootInit包括两个配置参数（[attachShadow文档](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/attachShadow)）

**mode** 属性，值可以是 `open` 或者 `closed` , 来控制是否通过页面内的 JavaScript 方法来获取 Shadow DOM

**delegatesFocus 焦点委托** 一个布尔值, 当设置为 `true` 时, 指定减轻自定义元素的聚焦性能问题行为

```javascript
//在节点上绑定shadow root,比如body
let bodyShadowRoot = document.body.attachShadow({mode: 'closed'});

//如果mode是open，可以从节点的shadowRoot属性获取Shadow tree的根节点
let bodyShadowRoot = document.body.shadowRoot;
```

> 注意：不是每一种类型的元素都可以绑定shadow root

任何带有有效的名称且可独立存在的（autonomous）自定义元素
```shell
<article>
<aside>
<blockquote>
<body>
<div>
<footer>
<h1>
<h2>
<h3>
<h4>
<h5>
<h6>
<header>
<main>
<nav>
<p>
<section>
<span>
```

##### 2.操作shadow root

有了shadow root就可以使用 DOM APIs对它进行操作，就和处理常规 DOM 一样；

```javascript
const watermarkWrap = document.createElement('div');
bodyShadowRoot.appendChild(watermarkWrap);
```

##### 3.添加 CSS 样式

```javascript
// 为 shadow DOM 添加一些 CSS 样式
const style = document.createElement('style');
style.textContent = `
.watermarkWrap {
  position: fixed;
  left: 0;
  top: 0;
  background-repeat: repeat;
	background-image:url("xx");
  background-size: 140px;
  width: 100%;
  height: 100%;
  background-attachment: fixed;
}
`;
```

##### 4.创建自定义元素

```javascript
// 为新元素创建一个类
class WordCount extends HTMLParagraphElement {
  constructor() {
    // 在构造器中先调用一下 super
    super();

    // 计数器指向元素的父级
    var wcParent = this.parentNode;

    function countWords(node){
      var text = node.innerText || node.textContent
      return text.trim().split(/\s+/g).length;
    }

    var count = 'Words: ' + countWords(wcParent);

    // 创建一个shadow root
    var shadow = this.attachShadow({mode: 'open'});

    // 创建文本节点并向其添加计数器
    var text = document.createElement('span');
    text.textContent = count;

    // 将其添加到shadow root上
    shadow.appendChild(text);

    // 当元素内容发生变化时更新计数
    setInterval(function() {
      var count = 'Words: ' + countWords(wcParent);
      text.textContent = count;
    }, 200);
  }
}

// 定义新元素
customElements.define('word-count', WordCount, { extends: 'p' });
```



### 4.MutationObserver防止修改水印

MutationObserver监听不到stylesheet变化，所以不采用生成stylesheet的方案





----



## 扩展延伸

### 使用WebGL

参考： [在Canvas中使用WebGL](https://www.cnblogs.com/mirror-pc/p/4181398.html)

