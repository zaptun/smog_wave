---
layout: post
filename: 2022-06-09-VUE2
title: VUE2
date: 2022-06-09 20:39:09 +0800
categories: 
tags: 
---

## vue 学习

### 1.相关知识

**MVC**

> MVC是单向的
> 可以看html看成view层，js看成controller层，ajax看成Model层，处理用户与应用的交互，响应对view的操作（对事件的监听），调用Model对数据进行操作，完成model与view的同步（根据model的改变，通过选择器对view进行操作） 

**MVVM**

> MVVM是双向的
> 它实现了View和Model的自动同步，也就是当Model的属性改变时，我们不用再自己手动操作Dom元素，来改变View的显示，而是改变属性后该属性对应View层显示会自动改变

### 2.生命周期

1. beforeCreate(创建前)
2. created(创建后)
3. beforeMounte(挂载前)
4. mounted(挂载后)
5. beforeUpdate(更新前)
6. updated(更新后)
7. beforeDestroy(销毁前)
8. destroyd(销毁后)

对应生命周期的api

- [beforeCreate](https://cn.vuejs.org/v2/api/#beforeCreate)
- [created](https://cn.vuejs.org/v2/api/#created)
- [beforeMount](https://cn.vuejs.org/v2/api/#beforeMount)
- [mounted](https://cn.vuejs.org/v2/api/#mounted)
- [beforeUpdate](https://cn.vuejs.org/v2/api/#beforeUpdate)
- [updated](https://cn.vuejs.org/v2/api/#updated)
- [activated](https://cn.vuejs.org/v2/api/#activated)
- [deactivated](https://cn.vuejs.org/v2/api/#deactivated)
- [beforeDestroy](https://cn.vuejs.org/v2/api/#beforeDestroy)
- [destroyed](https://cn.vuejs.org/v2/api/#destroyed)
- [errorCaptured](https://cn.vuejs.org/v2/api/#errorCaptured)

### 3.vue的虚拟DOM

Vue.js通过编译将模版转换成渲染函数(render)，执行渲染函数就可以得到一个虚拟DOM。

简单点讲，在Vue的实现上，Vue讲模版编译成虚拟DOM渲染函数。结合Vue自带的响应系统，在状态改变时，Vue能够智能地计算出重新渲染组件的最小代价并应用到DOM操作上。

### 4.组件通信

#### 4.1父组件通信子组件

##### 4.1.1 pros

基础功能，不特别给出示例了。

##### 4.1.2 $refs 

父组件调用子组件的方法，可以传递数据

> 注意：子组件标签中的时间也不区分大小写要用"-"隔开

**父组件:**

```vue
<template>
  <div id="app">
    <child-a ref="child"></child-a>
    <!--用ref给子组件起个名字-->
    <button @click="getMyEvent">点击父组件</button>
  </div>
</template>
<script>
  import ChildA from './components/child.vue'
  export default {
    components: {
      ChildA
    },
    data() {
      return {
        msg: "我是父组件中的数据"
      }
    },
    methods: {
      getMyEvent(){
          this.$refs.child.emitEvent(this.msg);
          //调用子组件的方法，child是上边ref起的名字，emitEvent是子组件的方法。
      }
    }
  }
</script>
```

**子组件：**

```vue
<template>
  <button>点击我</button>
</template>
<script>
  export default {
    methods: {
      emitEvent(msg){
        console.log('接收的数据--------->'+msg)//接收的数据--------->我是父组件中的数据
      }
    }
  }
</script>
```

#### 4.2 子组件通信父组件

##### 4.2.1 子$emit和父@|v-on

子组件调用父组件的方法并传递数据

> 注意：子组件标签中的时间也不区分大小写要用"-"隔开

**子组件：**

```vue
<template>
  <button @click="emitEvent">点击我</button>
</template>
<script>
  export default {
    data() {
      return {
        msg: "我是子组件中的数据"
      }
    },
    methods: {
      emitEvent(){
        this.$emit('my-event', this.msg)
        //通过按钮的点击事件触发方法，然后用$emit触发一个my-event的自定义方法，传递this.msg数据。
      }
    }
  }
</script>
```

**父组件：**

```vue
<template>
  <div id="app">
    <child-a @my-event="getMyEvent"></child-a>
    <!--父组件中通过监测my-event事件执行一个方法，然后取到子组件中传递过来的值-->
  </div>
</template>
<script>
  import ChildA from './components/child.vue'
  export default {
    components: {
      ChildA
    },
    methods: {
      getMyEvent(msg){
          console.log('接收的数据--------->'+msg)//接收的数据--------->我是子组件中的数据
      }
    }
  }
</script>
```

#### 4.3 子组件之间相互传递数据

兄弟组件之间相互传递数据

##### 4.3.1  $emit发送 $on接收

1. 首先创建一个vue的空白实例（兄弟间的桥梁） 

```javascript
// '../../../util/emptyVue'
import Vue from 'vue'
export default new Vue()
```

2. 子组件 childa，发送方使用 $emit 自定义事件把数据带过去

```vue
<template>
    <div>
        <span>A组件->{{msg}}</span>
        <input type="button" value="把a组件数据传给b" @click ="send">
    </div>
</template>
<script>
import vmson from "../../../util/emptyVue"
export default {
    data(){
        return {
            msg:{
            	a:'111',
            	b:'222'
            }
        }
    },
    methods:{
        send:function(){
            vmson.$emit("aevent",this.msg)
        }
    }
}
</script>
```

3. 子组件 childb，而接收方通过 $on 监听自定义事件的callback接收数据

```vue
<template>
 <div>
    <span>b组件,a传的的数据为->{{msg}}</span>
 </div>
</template>
<script>
	  import vmson from "../../../util/emptyVue"
	  export default {
		 data(){
		        return {
		            msg:""
		        }
		    },
		 mounted(){
		        vmson.$on("aevent",(val)=>{//监听事件aevent，回调函数要使用箭头函数;
		            console.log(val);//打印结果：我是a组件的数据
		            this.msg = val;
		        })
		  }
	}
</script>
```

4. 父组件：

```vue
<template>
     <div>
      <childa></childa>	
      <br />
      <childb></childb>  	
     </div>
</template>
<script>
   import childa from './childa.vue';
   import childb from './childb.vue';
   export default {
   	components:{
   		childa,
   		childb
   	},
   	data(){
   		return {
   			msg:""
   		}
   	},
   	methods:{
   	}
   }
</script>
```

#### 4.4 vue插件实现-各组件(父子,子子)通信

根据上面4.3.1的原理，封装为一个Vue的插件**vue-bus**，可以在所有的组件间任意使用

1. 新建vue-bus.js文件

首先，我们使用vue-cli创建一个项目vue-bus, 在src目录下，新建vue-bus.js文件，vue-bus插件像vue-router 和 Vuex一样，给Vue对象添加一个属性$bus,并代理$emit、$on、$off三个方法。代码如下：

```javascript
//vue-bus.js
export default {
  install: function(Vue, options) {
    Vue.prototype.$bus = new Vue({
      methods: {
        emit(event, ...args) {
          this.$emit(event, ...args);
        },
        on(event, callback) {
          this.$on(event, callback);
        },
        off(event, callback) {
          this.$off(event, callback);
        },
      },
    });
  },
};
```

2. 在main.js中使用插件，代码如下：

```javascript
//main.js
import Vue from 'vue';
import VueBus from './vue-bus';

Vue.use(VueBus);
```

3. 使用：建立父组件，两个子组件，father，childa，childb

```vue
<!-- father.vue -->
<template>
  <childa :number="number"></childa>
  <childb :number="number"></childb>
</template>

<script>
import childa from "./childa.vue";
import childb from "./childb.vue";
export default {
  components: {
    childa,
    childb,
  },
  data() {
    return {
      number: 0,
    };
  },
  methods: {
      handleAddRandom (num){
          this.number += num;
      }
  },
  created() {
      this.$bus.on('add',this.handleAddRandom);
  },
  beforeDestroy() {
      this.$bus.off('add',this.handleAddRandom)
  }
};
</script>
```

```vue
<!-- childa.vue -->
<template>
  <div>
    {{ number }}
    <button @click="handleAddRandom">通知父组件随机增加num</button>
    <button @click="callbrother">通知兄弟组件</button>
  </div>
</template>

<script>
export default {
  props: {
    number: {
      type: number,
    },
  },
  methods: {
    handleAddRandom() {
      //随机获取1～100
      const num = Math.floor(Math.random() * 100 + 1);
      this.$bus.emit("add", num);
    },
    callbrother(){
        this.$bus.emit("aevent", "i'm a");
    }
  }
};
</script>
```

```vue
<!-- childb.vue -->
<template>
  <div>
    {{ number }}
    <button @click="handleAddRandom">通知父组件随机增加num</button>
    <div>{{msg}}</div>
    <button @click="callbrother">通知兄弟组件</button>
  </div>
</template>

<script>
export default {
  props: {
    number: {
      type: number,
    },
  },
  created() {
    this.$bus.$on("aevent", this.getMsg);
  },
  methods: {
    handleAddRandom() {
      //随机获取1～100
      const num = Math.floor(Math.random() * 100 + 1);
      this.$bus.emit("add", num);
    },
    callbrother() {
      this.$bus.emit("bevent", "i'm b");
    },
    getMsg(val) {
      //监听事件aevent，回调函数要使用箭头函数;
      console.log(val); //打印结果：我是a组件的数据
      this.msg = val;
    }
  },
  beforeDestroy() {
      this.$bus.$off("aevent", this.getMsg);
  }
};
</script>
```

只需要很少的代码，就能够解决跨组件通信的问题，而且通过插件的形式使用后，所有组件都可以直接使用$bus，而无需每个组件都导入bus组件。

> 注意
>
> 1. $bus.on应该在created钩子内使用，如果在mounted使用，它可能接收不到其他组件来自created钩子内发出的事件;
> 2. 使用了$bus.on在beforeDestory钩子里应该需要使用$bus.off解除
> 3. 通信的eventName也不能重复，如果不同组建用一个名字，事件会误触发

### 5. Vue内置组件

在某些场景，往往需要我们动态切换页面部分区域的视图，这个时候内置组件component就显得尤为重要，component接收一个名为is的属性，is的值应为父组件中注册过的组件的名称，用法如下：

```vue
<component :is="view"></component>
<template>
  <div id="app">
    <ul class="tabs">
      <li class="per-tab" @click="toggleView('Home')">Home</li>
      <li class="per-tab" @click="toggleView('About')">About</li>
    </ul>
    <div class="tab-content">
      <component :is="view"></component>
    </div>
  </div>
</template>

<script>
let Home = {
  //Home组件
  template: '<p style="color: #787878;">Hello Home!</p>',
};
let About = {
  //About组件
  template: "<p>Hello About!</p>",
};
export default {
  name: "#app",
  components: { Home, About }, //组件注册
  data() {
    return {
      view: "Home",
    };
  },
  methods: {
    toggleView(view) {
      this.view = view;
    },
  },
};
</script>

<style scoped>
.tabs {
  margin: 0;
  padding: 0;
  list-style: none;
}
.per-tab {
  display: inline-block;
  width: 120px;
  line-height: 32px;
  border-left: 1px solid #ccc;
  border-top: 1px solid #ccc;
  background-color: azure;
}
.per-tab:last-child {
  border-right: 1px solid #ccc;
}
.tab-content {
  background-color: aqua;
  height: 240px;
  border: 1px solid #ccc;
}
</style> 
```



### 6. Vue中mixins



### 7. Vue中slot插槽

### 8. Vue中常用组件全局引入

1. 建一个公共组件目录`common_components/`，在里面建一个`index.js`文件，内容如下：

   ```javascript
   import Vue from 'vue';
   
   function changeStr(str) {
     return str.charAt(0).toUpperCase() + str.slice(1);
   }
   
   //三个参数 分别表示 1.指定路径（.指当前路径） 2.是否使用子目录 false/true 3.使用正则匹配
   const requireComponent = require.context('.', false, /\.vue$/)
   
   requireComponent.keys().forEach(filename => {
     const config = requireComponent(filename);
     const componentName = changeStr(filename.replace(/^\.\//, '').replace(/\.\w+$/, ''))
     Vue.component(componentName, config.default || config)
   })
   ```

2. 在mai n.js中引用

   ```javascript
   import '@/common_components';
   ```

   

### 9. Vue添加全局的方法属性

可以通过4.4 **install **插件的方式添加一个vue-utils插件，或者通过 **require.context** 扫描目录，再通过defineProperty的方式加到vue上，如下方式：

1. 建立一个通用方法目录`utools/`，建立`index.js`文件，内容如下：

   ```javascript
   //文件夹名说明 utools - universal tools 通用工具
   //目录说明，把所有通用方法统一在一个目录内，单独js，独立管理同时方便多人协同开发
   
   import Vue from "vue";
   let tools = {};
   
   /* require.context 三个参数
    * 1.指定路径（.指当前路径）
    * 2.是否使用子目录 false/true
    * 3.使用正则匹配
    */
   const files = require.context(".", true, /\.js$/);
   
   files.keys().forEach(key => {
     if (key === "./index.js") return;
     const funname = "$" + key.replace(/(.*?\/)(\w*)(\.js)/, "$2");
     const v = files(key).default;
     tools[funname] = files(key).default;
     Object.defineProperty(Vue.prototype, funname, { value: v });
   });
   
   export default tools;
   ```

   再定义方法文件，比如：getVersionNumber.js

   ```javascript
   export default function getVersionNumber(version) {
     return version
       .split(".")
       .reverse()
       .reduce((sum, item, idx) => sum + item * Math.pow(1000, idx), 0);
   }
   ```

   

2. main.js里面import

   ```javascript
   import "@/utools";
   ```

3. vue文件中调用

   ```javascript
   //1. 直接在vue文件script标签中使用
   this.$xxxxx();
   
   //2. vue中html模板使用绑定的全局函数，没有this
   $xxxx();
   ```

4. js文件调用

   ```javascript
   import utools from "@/utools";
   utools.$getVersionNumber('2.1.1');
   ```

   

### 10. webpack配置@路径别名

webpack.config.dev中的resolve下的alias属性做以下配置

```javascript
alias: {
  "@src":path.resolve("src"),
  "@component":path.resolve("src/component"),
  "@pages":path.resolve("src/pages"),
  "@utils":path.resolve("src/utils"),
},
```

然后使用
\- @src就可以指向到/src/
\- @component指向到/src/component/

使用：

```javascript
import LifeCycle from "@pages/lifecycle/lifecycle"
import stateProp from "@pages/stateProp/stateProp"
import Home from "@pages/home/home"
```

### 11. Vuex

#### 11.1 动态导入Vuex Store modules

**一、什么是module？**

> 背景：在Vue中State使用是单一状态树结构，应该的所有的状态都放在state里面，如果项目比较复杂，那state是一个很大的对象，store对象也将对变得非常大，难于管理。
>  module：可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。

**二、怎么用module？**

```javascript
const moduleA = {
    state: {... },
    mutations: {... },
    actions: {... },
    getters: {... }
}
const moduleB = {
    state: {... },
    mutations: {... },
    actions: {... }
}

const store = new Vuex.Store({
            state: {},
            modules: {
                a: moduleA,
                b: moduleB
            })
```

**三、动态导入store modules**

随着项目的复杂，文件结构越来越多，Store中modules中的文件也越来越多，一个个导入太麻烦，动态加载modules文件下的所有JS文件；**store.js** 修改如下

```javascript
import Vue from 'vue';
import Vuex from 'vuex';
Vue.use(Vuex);

const context = require.context('.', true, /\.js$/); //获取当前目录下所有js文件；
const moduleStores = {};
context.keys().forEach(key => {
  	if (key === "./index.js") return;
    const funname = "$" + key.replace(/(.*?\/)(\w*)(\.js)/, "$2");
    const v = context(key).default;
    //通过 context(key)导出文件内容。在文件中时通过 export.default 导出的，所以后边加.default
    moduleStores[funname] = {
        ...v,
        namespaced: true,//文件中有写可以省略；这样写可以不用给每个文件写入
    };
});

const rootStore = {         //全局根 store
    state: {...},
    actions: {...},
    mutations: {...},
    getters: {...}
}
           
export default new Vuex.Store({
	  ...rootStore,  
		modules: {
        ...moduleStores,
    },
});
```

#### 11.2 Vuex命名空间namespaced

默认情况下，模块内部的 action、mutation 和 getter 是注册在**全局命名空间**的，这样使得多个模块能够对同一 mutation 或 action 作出响应。如果希望你的模块具有更高的封装度和复用性，此时就用到了***\*命名空间\****这个概念。

**1.如何使模块成为一个命名空间模块？**

  你可以在单个模块中通过添加***\*namespaced：true\****的方式使其成为带命名空间的模块。

```javascript
import api from '~api'
 
const state = {
    vip: {},
}
 
const actions = {
    async ['get']({commit, state, dispatch}, config = {}) {
        try {
            const { data: { code, data } } = await api.post('vip/getVipBaseInfo', config)
            if (code === 1001) commit('receive', data)
        } catch(error) { console.log(error) }
    }
}
 
const mutations = {
    ['receive'](state, data) {
        state.vip = data
    }
}
 
const getters = {
    ['get'](state) {
        return state.vip
    },
}
 
export default {
    namespaced: true,  //开启namespace:true，该模块就成为命名空间模块了
    state,
    actions,
    mutations,
    getters
}
```

**2.组件中如何获取带有命名空间moduleA中的state数据？**

```javascript
//1、基本方式：
  this.$store.state.moduleA.countA
//2、mapState辅助函数方式：
  ...mapState({
      count:state=>state.moduleB.countB
  })
```

**3.组件中调用命名空间模块中的getters**

共有三种方式，如下：

```javascript
//1.
commonGetter(){
    this.$store.getters['moduleA/moduleAGetter']
},
//2.
...mapGetters('moduleA',['moduleAGetter']),此处的moduleA，不是以前缀的形式出现！！！
//3.别名状态下
...mapGetters({
    paramGetter:'moduleA/moduleAGetter'
}),
```

**4.组件中调用命名空间模块中的Mutations**

共有三种方式，如下：

```javascript
//1,3加个前缀moduleA/，都可以实现。2使用辅助函数未变名称的特殊点！！！
//1.
commonMutation(){
    this.$store.commit('moduleA/moduleAMutation');
},
//2.
...mapMutations('moduleA',['moduleAMutation']),
//3.别名状态下
...mapMutations({
    changeNameMutation:'moduleA/moduleAMutation'
})
```

**5.组件中调用命名空间模块中的Actions（与mutations一致）**

> 总结
>
>  在各模块使用了命名空间的情况下，即 namespaced: true 时：
>
> 组件中访问模块里的state
>
> 传统方法：
>
> ```javascript
> this.$store.state['模块名']['属性名']
> ```
>
> mapState方法：
>
> ```javascript
> import { mapState } from 'vuex'
> methods: {
>     ...mapActions({ updateNavStates: "navLeft/updateNavStates" }), //引入
>     ...
>     //使用
>     this.updateNavStates({
>       navSelected: item.type,
>     });
> }
> ```



**6.action中调用其它命名空间的action**

dispatch调用时，第三个参数传{ root: true }

```javascript
action:{
  async ["removeShopCar"]({ commit, state, dispatch }, config = {}) {
    dispatch("shop/rmGoodCount", config, { root: true });
    commit("removeShopCar", config);
    commit("setNeedUpload", true);
  },
}
```



### 12.Vue使用svg

1、安装依赖

依赖`svg-sprite-loader`，所以先安装`yarn add svg-sprite-loader --dev`；

2、新建svg资源目录

将svg资源放入此目录`src/assets/icons`，接下来会在配置文件中该路径

3、webpack配置loader

```javascript
{
    test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
    loader: "url-loader",
    exclude: [resolve("src/assets/icons")],  //排除icons目录
    options: {
        limit: 10000,
        name: "images/[name].[hash:8].[ext]",
    },
},
{
    test: /\.svg$/,
    loader: "svg-sprite-loader",
    include: [resolve("src/assets/icons")], //加入icons目录
    options: {
        symbolId: "icon-[name]",
    },
},
{
    test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
    loader: "url-loader",
    options: {
        esModule: false,
        fallback: "file-loader?esModule=false",
        // limit: 20 * 1024,
    },
},
```

4、创建SvgIcon.vue

`src/compoments/SvgIcon.vue`

```vue
<template>
  <svg :class="svgClass" aria-hidden="true" :width="width" :height="height">
    <use :xlink:href="iconName"></use>
    <slot />
  </svg>
</template>

<script>
export default {
  name: "svg-icon",
  props: {
    iconClass: {
      type: String,
      required: true,
    },
    className: {
      type: [String, Array],
      default: "",
    },
    width: {
      type: [Number, String],
      default: 12,
    },
    height: {
      type: [Number, String],
      default: 12,
    },
  },
  computed: {
    iconName() {
      return `#icon-${this.iconClass}`;
    },
    svgClass() {
      if (this.className) {
        return "svg-icon " + this.className;
      } else {
        return "svg-icon";
      }
    },
  },
};
</script>

<style lang="less" scoped>
.svg-icon {
  vertical-align: -0.15em;
  fill: currentColor;
  overflow: hidden;
}
</style>
```

5、组件注册

`src/assets/icons/index.js`

```javascript
import Vue from "vue";
import SvgIcon from "../../components/SvgIcon/index.vue";

Vue.component("svg-icon", SvgIcon);

const requireAll = requireContext => requireContext.keys().map(requireContext);
const req = require.context("./svg", true, /\.svg$/);
// const iconMap = requireAll(req)
// console.log(iconMap)
requireAll(req);
```

6、全局挂载svg组件

`main.js`

```javascript
import './assets/icons'
```

7、使用svg组件

iconClass: svg文件的文件名
className: svg图标的样式类名

```vue
<template>
  <svg-icon iconClass='svg-name' className='icon'></svg-icon>
	<svg-icon class="icon" :icon-class="v.icon" width="12" height="12" />
</template>

<style scoped>
.icon {
  width: 100px;
  height: 100px;
  color: red;
}
</style>
```

> 备注：如果颜色没有改变，打开svg文件，搜索fill，都删除

### 13. TypeScript + eslint 格式化代码

**1、计划目标**

1. 使用 eslint、prettier 格式化 TypeScript 代码
2. 使用 husky、lint-staged 在提交代码到 git 的时候自动格式化代码（按需启用）
3. 使用 commitlint 校验 git commit message（按需启用）

> 关于 1  eslint、prettier 配合使用的方式是后者先按其规则格式化代码，然后使用 eslint --fix 再次格式化，从而达到代码兼容二者格式的目的。

**2、依赖**

```javascript
npm i -D eslint prettier
npm i -D eslint-config-prettier eslint-plugin-prettier
npm i -D @typescript-eslint/eslint-plugin @typescript-eslint/parser

npm i -D husky lint-staged
npm i -D @commitlint/cli @commitlint/config-conventional
```

**3、配置**

package.json 同级目录下配置如下文件

#### **eslint配置**

采用 .eslintrc.js(对于这些配置，优先选择 js 格式，不说别的，一个注释就比 json 格式强的多)。

```javascript
module.exports = {
    root: true,
    parser: '@typescript-eslint/parser',
    extends: [
        'plugin:@typescript-eslint/recommended',
        // Uses eslint-config-prettier to disable ESLint rules from @typescript-eslint/eslint-plugin that would conflict with prettier
        'prettier/@typescript-eslint',
        // Enables eslint-plugin-prettier and eslint-config-prettier. This will display prettier errors as ESLint errors. Make sure this is always the last configuration in the extends array.
		// 此行必须在最后
        'plugin:prettier/recommended',
    ],
    env: {
        es6: true,
        node: true,
    },
    parserOptions: {
        // 支持最新 JavaScript
        ecmaVersion: 2018,
        sourceType: 'module',
    },
    rules: {
        // 如果有不适合的规则，可以在此调整
		// ...
    },
};
```

当然，上面是单纯的 node 下使用 TypeScript 的配置，如果是 react 之类的，可以再加上相应配置。

#### **prettier**配置

配置文件为：.prettierrc.js

```javascript
module.exports = {
    // 箭头函数只有一个参数的时候可以忽略括号
    arrowParens: 'avoid',
    // 括号内部不要出现空格
    bracketSpacing: false,
    // 行结束符使用 Unix 格式
    endOfLine: 'lf',
    // true: Put > on the last line instead of at a new line
    jsxBracketSameLine: false,
    // jsx 属性使用双引号
    jsxSingleQuote: false,
    // 行宽
    printWidth: 100,
    // 换行方式
    proseWrap: 'preserve',
    // 分号
    semi: true,
    // 使用单引号
    singleQuote: true,
    // 缩进
    // tabWidth: 4,
    // 使用空格缩进
    useTabs: false,
    // 后置逗号，多行对象、数组在最后一行增加逗号
    trailingComma: 'es5',
    // parser: 'babylon',
};
```

如果某些代码不需要格式化，可以在 .prettierignore 中配置，格式类似 .gitignore

#### git 提交时候的代码格式化

**.huskyrc.js**

```javascript
module.exports = {
  hooks: {
    // git message 格式控制，参见下面的 git commit message 校验部分，如果不需要可删除
    'commit-msg': 'commitlint -E HUSKY_GIT_PARAMS',

	// commit 之前执行的命令
    'pre-commit': 'lint-staged',
  },
};
```

**lint-staged.config.js**

ts、js 之类代码使用 eslint 格式化，md、css 之类则用 prettier。

```javascript
module.exports = {
    linters: {
        '*.{ts,tsx}': ['eslint --fix', 'git add'],
        '*.{js,jsx}': ['eslint --fix', 'git add'],
        '*.{md,html,json}': ['prettier --write', 'git add'],
        '*.{css,scss,less}': ['prettier --write', 'git add'],
    },
};
```

#### git commit message 格式控制

这个用来控制 git 提交信息是否符合规范，我一般使用 ，具体可参见[说明](https://commitlint.js.org/)。

简单来说，git 提交信息需符合如下规则：

```javascript
type(scope?): subject
body?
footer?
```

.commitlintrc.js

此文件在 .huskyrc.js 中配置 commit-msg 后启用。

```javascript
module.exports = {
  extends: ['@commitlint/config-conventional'],
};
```

#### 命令配置

为方便检查代码格式是否存在错误，或者直接格式化所有代码，可以在 package.json 的 script 中配置如下命令：

```javascript
"lint": "eslint 'src/**/*.{js,ts,tsx}'",
"format": "eslint --fix 'src/**/*.{js,ts,tsx}'",
```

前者用来检查代码是否存在格式问题。后者用来修正代码格式。

### 14. 基于axios封装api请求

#### 14.1 创建实例 `utils/fetch.js`

axios 默认提交格式为：`application/json`
可使用 qs 模块(需要安装)转换后提交格式为 `application/x-www-form-urlencoded`
通过设置 transformRequest 属性 `data => qs.stringify(data)` 可以正常表单形式提交

```javascript
import axios from 'axios'

const instance = axios.create({
  baseURL: 'apiBaseUrl', // api的base_url
  timeout: 10000 // 请求超时时间
  // transformRequest: data => qs.stringify(data) //
})
// request拦截器
instance.interceptors.request.use(
  e => {
    e.params = e.params || {}
    e.headers = e.headers || {}
    //set 默认值
    return e
  },
  error => ({ status: 0, msg: error.message })
)
// respone拦截器
instance.interceptors.response.use(
  response => {
    const resp = response.data
    if (response.status === 200) {
      return resp
    }
    return resp
  },
  error => {
    console.log('err' + error) // for debug
    return Promise.reject(error)
  }
)
export default instance
```

#### 14.2 将 api 请求封装到 api 文件夹下

在 api 文件中新建接口模块并使用 axios 实例(utils/fetch.js) 

src/api/api_test.js内容如下：

```javascript
import request from '@/utils/fetch'

export function test(data) {
  return request({
    url: '/test',
    method: 'post',
    data: data
  })
}
```

#### 14.3 使用

使用的时候，可通过引入 api/模块.js 调用方法，也可以通过安装插件的形式将 api 接口扩展到 vue 实例中，使其可以更方便的在项目中使用

**以 test 模块为例创建一个$api 扩展**

src/api/index.js内容：

```javascript
import * as api_test from './test'

const apiObj = {
  api_test
}

const install = function(Vue) {
  if (install.installed) return
  install.installed = true
  Object.defineProperties(Vue.prototype, {
    $api: {
      get() {
        return apiObj
      }
    }
  })
}
export default {
  install
}
```

在 main.js 安装 $api 扩展:

```javascript
import api from './api'
Vue.use(api)
```

在项目中调用：

```javascript
this.$api.api_test.test().then(resp=>{...}).catch(()=>{...})
```



#### 14.4 axios设置重试机制

[参考](https://github.com/axios/axios/issues/164)

```javascript
axios.interceptors.response.use(undefined, function axiosRetryInterceptor(err) {
    var config = err.config;
    // If config does not exist or the retry option is not set, reject
    if(!config || !config.retry) return Promise.reject(err);
    
    // Set the variable for keeping track of the retry count
    config.__retryCount = config.__retryCount || 0;
    
    // Check if we've maxed out the total number of retries
    if(config.__retryCount >= config.retry) {
        // Reject with the error
        return Promise.reject(err);
    }
    
    // Increase the retry count
    config.__retryCount += 1;
    
    // Create new promise to handle exponential backoff
    var backoff = new Promise(function(resolve) {
        setTimeout(function() {
            resolve();
        }, config.retryDelay || 1);
    });
    
    // Return the promise in which recalls axios to retry the request
    return backoff.then(function() {
        return axios(config);
    });
});
```

To use:

```javascript
axios.get('/some/endpoint', { retry: 5, retryDelay: 1000 })
.then(function(res) {
    console.log('success', res.data);
})
.catch(function(err) {
    console.log('failed', err);
});
```



### 15. 多国语言支持插件

先在全局store设置lang参数，和相关方法：

```javascript
// store/index.js
import Vue from "vue";
import Vuex from "vuex";
Vue.use(Vuex);

const context = require.context(".", true, /\.js$/);
const moduleStores = {};
context.keys().forEach(key => {
  if (key === "./index.js") return;
  const funname = key.replace(/(.*?\/)(\w*)(\.js)/, "$2");
  const v = context(key).default;
  moduleStores[funname] = {
    ...v,
    namespaced: true,
  };
});
const rootStore = {
  //全局根 store
  state: {
    language: "en", //默认语言
    lang: null,
    ...
  },
  actions: {
    async ["setLanguage"]({ commit, state, dispatch }, config = {}) {
      commit("setLanguage", config.language);
      commit("setLang", config.i18n);
    },
  },
  mutations: {
    ["setLanguage"](state, data) {
      state.language = data;
    },
    ["setLang"](state, i18n) {
      state.lang = i18n.getLang(state.language);
    },
  },
  getters: {
    ...
  },
};

export default new Vuex.Store({
  ...rootStore,
  modules: {
    ...moduleStores,
  },
});
```

```javascript
// utils/i18n/index.js
import en from "./en";
import zh from "./zh";

//i18n.js
var i18n = {};
i18n.install = function(Vue, options) {
  Vue.prototype.$i18n = {
    getLang(language) {
      let lang = null;
      switch (language) {
        case "en":
          lang = en;
          break;
        case "zh":
          lang = zh;
          break;
        default:
          lang = en;
          break;
      }
      return lang;
    },
  };
};
export default i18n;
```

```javascript
// utils/i18n/en.js
export default {
  menu: {
    home: "home",
  },
  content: {
    main: "this is content",
  },
};
```

```javascript
// src/app.js
//设置i18n
import i18n from "@/utils/i18n";
Vue.use(i18n);
```

```javascript
// src/app.vue
...
beforeCreate() {
  this.$store.dispatch("setLanguage", { language: "en", i18n: this.$i18n });
},
...
```



### 16. vue图片资源加载

两种方式:

#### 16.1 放 **assets** 目录

 `assets/imgs/xxx.png`

```vue
// 在vue文件中img标签调用
<template>
<img width="100%" height="300" :src="ad01" />  //src指向变量
</template>

<script>
export default {
  data() {
    return {
      ad01: require("@/assets/imgs/xxx.png"),  //script中require需要的图片
    };
  },
};
</script>

// 在vue文件中css样式调用
<template>
<div class="test"></div>
</template>
<script>
import "./ad.scss";
...
</script>
```

ad.scss 中

```css
.test{
    width: 100%;
    height: 200%;
    background: url(../../assets/imgs/logo.png);   //写入地址
}
```



#### 16.2 放 **static** 目录

`static/imgs/xxx.png`

```vue
// 在vue文件中img标签调用
<template>
<img width="100%" height="300" src="@/static/imgs/logo.png" />  //直接引用
</template>
```

```vue
// 在vue文件中css样式调用
<template>
<div class="test-static"></div>
</template>
<script>
import "./ad.scss";
...
</script>
```

ad.scss 中

```css
.test-static{
    width: 100%;
    height: 200%;
    background: url(../../static/imgs/logo.png);
}
```



### 17. Sass全局引入变量文件和混入文件

[参考](https://blog.csdn.net/kongduxue/article/details/82694210)

1.首先安装sass-resources-loader

```shell
npm install sass-resources-loader --save-dev
```

2.全局引入变量文件(common.scss)和混入文件(common-mixin.scss)

```javascript
return {
    css: generateLoaders(),
    postcss: generateLoaders(),
    less: generateLoaders('less'),
    sass: generateLoaders('sass', { indentedSyntax: true }),
    scss: generateLoaders('sass').concat({
      loader: 'sass-resources-loader',
      options: {
        resources: [
          path.resolve(__dirname,'./../src/assets/scss/common.scss'),
          path.resolve(__dirname,'./../src/assets/scss/common-mixin.scss')
        ]
      }
    }),
    stylus: generateLoaders('stylus'),
    styl: generateLoaders('stylus')
}
```

```javascript
{
  test: /\.(sa|sc)ss$/,
  use: [
    env === "development"
      ? "style-loader"
      : {
          loader: MiniCssExtractPlugin.loader,
          options: {
            publicPath: "../",
          },
        },
    "css-loader",
    "postcss-loader",
    "sass-loader",
    {
      loader: "sass-resources-loader",
      options: {
        resources: [
          resolvePath("src/assets/css/common.scss"),
          resolvePath("src/assets/css/common-mixin.scss"),
        ],
      },
    },
  ],
},
```

3.main.js 中引入你的需要引入的公共模块的scss文件

```javascript
import './assets/common.scss'
```



### 18. 全局logger日志模块

**src/logger.js**  [logger](https://github.com/chuuddo/shri-2020-hw-ci/blob/e3cf4d7d92569e3683b0e20393e46b04b95c2d67/packages/shared/src/logger.js)

```javascript
const { format, createLogger, transports } = require("winston");

module.exports = createLogger({
  format: format.combine(
    format.timestamp({ format: "YYYY-MM-DD HH:mm:ss" }),
    format.errors({ stack: true }),
    format.colorize({ all: true }),
    format.printf(info => `${info.timestamp} ${info.level} - ${info.message}`)
  ),
  transports: [new transports.Console()]
});
```

使用

```javascript
const logger = require("./logger");
logger.warn(`Retry attempt #${cfg.currentRetryAttempt}\n${JSON.stringify(data, null, 2)}`);
```







## 踩坑

### 1. axios无法配置HttpAdapter

**HttpAdapter with electron, vue and webpack**

安装axios，发现它的package里面browser配置指向xhr，虽然在构建时定义

```javascript
import axios from "axios";
import httpAdapter from "axios/lib/adapters/http";
axios.defaults.adapter = httpAdapter;

```

依旧没有走http adapter, axios库依赖package.json中的 'browser' 键告诉webpack重写适配器为XHR, 而且如果在webpack配置中指定target：'electron-renderer'，它仍将不包含http适配器，因为它使用了webpack的“浏览器”别名替代功能

**解决思路：**

移除axios的package内browser键，阻止它的默认配置，每次安装时，做个替换，把这个文件替换一下；

```json
// 整个工程的package文件配置postinstall
"postinstall": "node ./scripts/postinstall.js"
```

```javascript
// postinstall.js

const fs = require("fs");
const path = require("path");
const exec = require("child_process").exec;

/*
 * 复制目录、子目录，及其中的文件
 * @param src {String} 要复制的目录
 * @param dist {String} 复制到目标目录
 */
function copyDir(src, dist, callback) {
  fs.access(dist, function(err) {
    if (err) {
      // 目录不存在时创建目录
      fs.mkdirSync(dist);
    }
    _copy(null, src, dist);
  });

  function _copy(err, src, dist) {
    if (err) {
      callback(err);
    } else {
      fs.readdir(src, function(err, paths) {
        if (err) {
          callback(err);
        } else {
          paths.forEach(function(path) {
            var _src = src + "/" + path;
            var _dist = dist + "/" + path;
            fs.stat(_src, function(err, stat) {
              if (err) {
                callback(err);
              } else {
                // 判断是文件还是目录
                if (stat.isFile()) {
                  fs.writeFileSync(_dist, fs.readFileSync(_src));
                } else if (stat.isDirectory()) {
                  // 当是目录是，递归复制
                  copyDir(_src, _dist, callback);
                }
              }
            });
          });
        }
      });
    }
  }
}
copyDir(
  path.resolve(__dirname, "./replace"),
  path.resolve(__dirname, "../node_modules")
);

/**
 * 修改axios 的package文件
 */
function changeAxiosPackage(){
  const packagePath = path.resolve(__dirname, "../node_modules/axios/package.json");
  const packageContent = fs.readFileSync(packagePath,'utf8');
  const newContent = packageContent.replace(/\n/g,'#@#').replace(/"browser.*?\{.*?\},/,'').replace(/#@#/g,'\n');
  fs.writeFileSync(packagePath, newContent, 'utf8');
}
changeAxiosPackage();
```

replace文件夹结构

```shell
-- replace/
 |-- axios/
 		|-- package.json //直接替换文件 这个文件内，删除browse这个配置
```



### 2. axios增加错误重试

使用 axios-retry 插件，一般使用方法:  [npm参考](https://www.npmjs.com/package/retry-axios)

```javascript
// 添加响应拦截器
React.Component.prototype.$ajax.interceptors.response.use(function (response) {
    // 对响应数据做点什么
    return response;
  }, function (error) {
    // 对响应错误做点什么
    document.getElementsByClassName("ajaxMask")[0].style.display="flex";
    console.log("错误")    
    setTimeout(function(){            
        return axios(error.config)
    },2000)
       
    return Promise.reject(error);
});
```

上面这种我没有写发送请求次数，下面这种通过插件配合一些人的文档得出以下使用方法

```javascript
//配置axios
axiosRetry(axios, { 
    retries: 1,  //设置自动发送请求次数
    retryDelay: (retryCount) => {        
        return retryCount * 1000;
    },
    shouldResetTimeout:true,
    retryCondition: (error)=>{        
        //true为打开自动发送请求，false为关闭自动发送请求
        //这里的意思是当请求方式为get时打开自动发送请求功能
        return (error.config.method === 'get' || error.config.method === 'post');
    }
});
```

### 项目中 http-interceptors.js 例子

```javascript
import fs from "fs";
import qs from "qs";
import https from "https";
import axios from "axios";
import * as rax from "retry-axios";
import httpAdapter from "axios/lib/adapters/http";
import Md5 from "crypto-js/md5";
import store from "@/store/index";
import { PFX_PATH, PFX_PASSPHRASE, APP_VERSION_LONG } from "@/configs/system";
import { remote, ipcRenderer } from "electron";
import logger from "@/lib/log";
axios.defaults.adapter = httpAdapter;

function getGlobal(name) {
  try {
    const res = remote.getGlobal(name);
    return res;
  } catch {
    return global[name];
  }
}
let httpsAgent = null;
try {
  httpsAgent = new https.Agent({
    pfx: fs.readFileSync(PFX_PATH),
    passphrase: PFX_PASSPHRASE,
    agent: false,
    rejectUnauthorized: false,
    keepAlive: true,
  });
} catch (e) {
  logger("appException").error(e);
}

function encrypt(obj) {
  let keys = Object.keys(obj).sort();
  keys = keys.filter(
    key => obj[key] !== null && obj[key] !== undefined && obj[key] !== ""
  );
  const values = keys
    .map(key => {
      return key + "=" + obj[key];
    })
    .join("&");
  const res = values + `&sk=${store.state.loginInfo.userInfo.sk}`;
  return Md5(res)
    .toString()
    .toUpperCase();
}

/**
 * 请求配置
 * @see https://github.com/mzabriskie/axios
 */

const instance = axios.create({
  timeout: 1000 * 5 * 60, // 请求超时时间
  withCredentials: true, // 跨域
  adapter: httpAdapter,
  httpsAgent,
});
instance.defaults.raxConfig = {
  instance: instance,
  retry: 3,
  noResponseRetries: 2,
  retryDelay: 100,
  httpMethodsToRetry: ["GET", "HEAD", "OPTIONS", "DELETE", "PUT"],
  statusCodesToRetry: [
    [100, 199],
    [429, 429],
    [500, 599],
  ],
  onRetryAttempt: err => {
    const cfg = rax.getConfig(err);
    console.log(`Retry attempt #${cfg.currentRetryAttempt}`);
    loggerHttpResponse("error", {
      message: `Retry attempt #${cfg.currentRetryAttempt}`,
    });
  },
};
rax.attach(instance);
// const interceptorId = rax.attach(instance);

function sortObjByKey(obj) {
  if (Object.prototype.toString.call(obj) === "[object Object]") {
    const keys = Object.keys(obj).sort();
    const newObj = {};
    for (let i = 0; i < keys.length; i++) {
      let index = keys[i];
      newObj[index] = obj[index];
    }
    return newObj;
  } else {
    return {};
  }
}

function loggerHttpResponse(type, res) {
  let { config, status = "", statusText = "", errorCode = "", data: ret } = res;
  const { url = "", method, params, data } = config;
  const requestData = method === "get" ? params : qs.parse(data);
  if (type === "error") {
    try {
      statusText = res.message;
      status = res.response.status;
      errorCode = res.code;
      ret = res.response.data;
    } catch (e) {
      ret = e;
    }
  }
  logger("http")[type]({
    method,
    url,
    requestData,
    status,
    statusText,
    errorCode,
    data: ret ? JSON.stringify(ret) : "",
  });
}

instance.interceptors.request.use(
  config => {
    let data = sortObjByKey(config.data);
    const wifiInfo = getGlobal("wifiInfo") || {};
    const networkAddress = getGlobal("networkAddress") || {};
    const { ssid = "", bssid = "" } = wifiInfo;
    const { ip = "", mac = "" } = networkAddress;
    if (store.state.loginInfo.userInfo && store.state.loginInfo.userInfo.t) {
      if (config.method === "get") {
        let params = config.params || {};
        if (ssid) {
          params.ssid = ssid;
        }
        if (bssid) {
          params.bssid = bssid;
        }
        if (ip) {
          params.ip = ip;
        }
        if (mac) {
          params.mac = mac;
        }
        params.ts = Date.now();
        params.v = APP_VERSION_LONG;
        const s = encrypt(params);
        let obj = sortObjByKey({
          ...params,
          s,
        });
        config.params = obj;
        if (store.state.loginInfo.userInfo.t) {
          config.params.t = store.state.loginInfo.userInfo.t;
        }
      } else {
        try {
          data.ts = Date.now();
          data.v = APP_VERSION_LONG;
          if (ssid) {
            data.ssid = ssid;
          }
          if (bssid) {
            data.bssid = bssid;
          }
          if (ip) {
            data.ip = ip;
          }
          if (mac) {
            data.mac = mac;
          }
          data.s = encrypt(data);
          data = sortObjByKey(data);
          data.t = store.state.loginInfo.userInfo.t;
        } catch (e) {}
      }
    }

    const ContentType = config.headers["Content-Type"];
    if (ContentType && ContentType.indexOf("x-www-form-urlencoded") > -1) {
      config.data = qs.stringify(data);
    }
    return config;
  },
  error => {
    // noticeLog({ text: "ajax-paramsIn-error", data: error });
    logger("http").error("request paramsIn error", error);
    logger("appException").error("request paramsIn error", error);
    Promise.reject(error);
  }
);

instance.interceptors.response.use(
  response => {
    let {
      status,
      data: { code },
    } = response;
    // noticeLog({ text: "ajax-response", data: response });
    // logger("http").info(response.config.method === "get");
    loggerHttpResponse("info", response);
    //TODO: 需要和后端同学约定好
    if (status === 200 && code == 0) {
      return response.data || {};
    } else {
      if (code === 1401) {
        ipcRenderer.send("logout");
      }
      return Promise.reject(response.data);
    }
  },
  error => {
    // noticeLog({ text: "ajax-response-error", data: error });
    loggerHttpResponse("error", error);
    logger("appException").error("response error", error);
    return Promise.reject(error);
  }
);

export default instance;
```

### 3. 网络不好导致的安装失败

可以用**nrm**切换npm的源

介绍：nrm(npm registry manager )是npm 资源管理器，允许你快速切换npm 源

常用命令：

```shell
npm install -g nrm  #nrm 安装
nrm ls  #列出可用的源
nrm use taobao #选择国内淘宝的源
nrm test npm #测试速度
nrm add taobao http://192.168.10.127:8081/repository/npm-public/  #添加源
nrm del  taobao #删除对应的源
```

### 4. css scoped没起效

因为Vue-loader 15开始不支持HappyPack，官方推荐用thread-loader替换，把配置中使用HappyPack的部分去掉就可以了；

```javascript
rules: [{
            test: /\.less$/,
            oneOf: [{
                    resourceQuery: /module/,
                    use: [
                        // "css-hot-loader",
                        // MiniCssExtractPlugin.loader,
                        "vue-style-loader",
                        {
                            loader: "css-loader",
                            options: {
                                modules: true,
                                localIdentName: "[path][name]---[local]---[hash:base64:5]",
                                camelCase: true,
                            },
                        },
                        "less-loader",
                    ],
                },
                {
                    use: ["vue-style-loader", "css-loader", "less-loader"],
                },
            ],
        },
        {
            test: /\.s([ac])ss$/,
            use: [
                // ...cssHotLoader,
                "vue-style-loader",
                "css-loader?minimize",
                "sass-loader",
                {
                    loader: "sass-resources-loader",
                    options: {
                        resources: [
                            resolve("src/assets/sass/common.scss"),
                            resolve("src/assets/sass/common-mixin.scss"),
                        ],
                    },
                },
            ],
        },
        {
            test: /\.css$/,
            use: [
                ...cssHotLoader,
                // "style-loader",
                "happypack/loader?id=css",
                // {
                //     loader: "happypack/loader?id=css",
                // },
            ],
        },
        {
            test: /\.vue$/,
            loader: "vue-loader",
            options: {
                cssModules: {
                    localIdentName: "[path][name]---[local]---[hash:base64:5]",
                    camelCase: true,
                },
                loaders: {
                    ...cssHotLoader,
                    less: "vue-style-loader!css-loader!less-loader",
                    scss: "vue-style-loader!css-loader!sass-loader",
                    sass: "vue-style-loader!css-loader!sass-loader",
                },
            },
        },
        {
            test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
            loader: "url-loader",
            exclude: [resolve("src/assets/icons")],
            options: {
                esModule: false,
                limit: 100,
                name: "images/[name].[hash:8].[ext]",
            },
        },
        {
            test: /\.svg$/,
            loader: "svg-sprite-loader",
            include: [resolve("src/assets/icons")],
            options: {
                symbolId: "icon-[name]",
            },
        },
        {
            test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
            loader: "url-loader",
            options: {
                esModule: false,
                fallback: "file-loader?esModule=false",
                limit: 100,
                name: "font/[name].[hash:8].[ext]",
            },
        },
    ],
},
```

### 5. MiniCssExtractPlugin.loader和vue-style-loader冲突

用process.env.NODE_ENV 判断，生产环境再用MiniCssExtractPlugin.loader. 参考：[vue loader webpack4](https://vue-loader.vuejs.org/zh/guide/extract-css.html#webpack-4)

```javascript
// webpack.config.js
var MiniCssExtractPlugin = require('mini-css-extract-plugin')

module.exports = {
  // 其它选项...
  module: {
    rules: [
      // ... 忽略其它规则
      {
        test: /\.css$/,
        use: [
          process.env.NODE_ENV !== 'production'
            ? 'vue-style-loader'
            : MiniCssExtractPlugin.loader,
          'css-loader'
        ]
      }
    ]
  },
  plugins: [
    // ... 忽略 vue-loader 插件
    new MiniCssExtractPlugin({
      filename: 'style.css'
    })
  ]
}
```



### 6. scoped属性并@import引入外部css, 作用域是全局问题

```css
<style scoped>
    @import '../../assets/css/home.css';  
</style>
/*这样写的话import的css文件会被编译为全局样式，但是引入less等预编译文件，就会局部生效*/

<style src="../../assets/css/home.css" scoped></style>
/*这样写的css文件中的样式只能在本组件中使用，而不会影响其他组件*/
```

### 7. sass加了scoped后样式丢失

```html
<style lang="scss" scoped src="./sass/ChatList.scss"></style>
```

如上代码，加scoped后样式丢失，不加则可以；原因使用 `scoped` 后，父组件的样式将不会渗透到子组件中。不过一个子组件的根节点会同时受其父组件的 scoped CSS 和子组件的 scoped CSS 的影响。这样设计是为了让父组件可以从布局的角度出发，调整其子组件根元素的样式。如果你希望 `scoped` 样式中的一个选择器能够作用得“更深”，例如影响子组件，你可以使用 `>>>` 操作符。这种情况下你可以使用 `/deep/` 或 `::v-deep` 操作符取而代之——两者都是 `>>>` 的别名，同样可以正常工作。

> 优先建议使用 ::v-deep 来处理，/deep/有时会因为配置问题无效



### 8. AXIOS Socket Hang Up

经常出现网络超时，socket hang up问题；



## 附

### 1. webpack配置参考

#### **webpack.electron.base.js**	

```javascript
const path = require("path");
const webpack = require("webpack");
const package = require("../../package.json");
// const SentryCliPlugin = require("@sentry/webpack-plugin");
function resolve(dir) {
  return path.join(__dirname, "../../", dir);
}
// const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
const SERVER_TARGET = `${process.env.SERVER_TARGET || "prod"}`;
const NODE_ENV = `${process.env.NODE_ENV}`;
const VERSION = `${package.version}`;
const release = `bosshi-${SERVER_TARGET}-${NODE_ENV}-${VERSION}`;
// const { CleanWebpackPlugin } = require('clean-webpack-plugin');
const DEBUG = process.env.NODE_ENV === "production" ? !1 : !0;
const BASE_CONFIG = {
  // 减少webpack 输出
  // stats:"errors-only",
  stats: {
    children: false,
    colors: true,
    warningsFilter: [
      // "Conflicting order between"
    ],
  },
  devtool: DEBUG ? "source-map" : false,
  // devtool: "source-map" ,
  module: {
    rules: [
      {
        test: /\.(sql|proto)$/i,
        use: "raw-loader",
      },
    ],
  },
  plugins: [
    // new CleanWebpackPlugin({cleanOnceBeforeBuildPatterns:[resolve('dist/renderer')]}),
    new webpack.EnvironmentPlugin({
      SERVER_TARGET: process.env.SERVER_TARGET,
      NODE_ENV: process.env.NODE_ENV,
      VERSION: package.version,
      RELEASE_VERSION: release,
    }),
    // new BundleAnalyzerPlugin(
    //   {
    //     analyzerMode: 'server',
    //     analyzerHost: '127.0.0.1',
    //     analyzerPort: 9999,
    //     reportFilename: 'report.html',
    //     defaultSizes: 'parsed',
    //     openAnalyzer: true,
    //     generateStatsFile: false,
    //     statsFilename: 'stats.json',
    //     statsOptions: null,
    //     logLevel: 'info'
    //   }
    // ),
  ],
  resolve: {
    extensions: [".js", ".vue", ".json"],
    alias: {
      "vue$": "vue/dist/vue.esm.js",
      "@": resolve("src"),
    },
  },
  watchOptions: {
    // 使用自动刷新：不监听的 node_modules 目录下的文件
    ignored: /node_modules/
  },
};


// if (process.env.SERVER_TARGET === "qa") {
//   BASE_CONFIG.plugins.push(
//     new SentryCliPlugin({
//       release: package.version,
//       include: "./dist",
//       release: release,
//       configFile: "sentry.properties",
//       ignore: ["node_modules/", "build/"],
//     })
//   );
// }

module.exports = BASE_CONFIG;
```



#### **webpack.electron.main.js**

```javascript
//webpack.electron.main.js
const merge = require("webpack-merge");
const base = require("./webpack.electron.base");

// const isProduction = process.env.NODE_ENV === "production";

module.exports = merge(base, {
  target: 'electron-main'
});
```



#### **webpack.electron.renderer.js**

```javascript
const merge = require("webpack-merge");
const base = require("./webpack.electron.base");
const HappyPack = require("happypack");
const MiniCssExtractPlugin = require("mini-css-extract-plugin");
const HtmlWebpackPlugin = require("html-webpack-plugin");
const TerserPlugin = require("terser-webpack-plugin");
const path = require("path");
const os = require('os');
const happyThreadPool = HappyPack.ThreadPool({ size: os.cpus().length });


function resolve(dir) {
    return path.join(__dirname, "../../", dir);
}

module.exports = function(config) {
    // const miniLoaders = [MiniCssExtractPlugin.loader];
    const cssHotLoader = process.env.NODE_ENV !== 'production' ? ['css-hot-loader', 'vue-style-loader'] : [MiniCssExtractPlugin.loader];

    const notCssModules = config.module.rules.filter(
        rule => !/css|less|s\(\[ac\]\)ss|vue/.test(rule.test.toString())
    );
    const svgModulesIndex = notCssModules.findIndex(
        rule => rule.test == /\.(png|jpe?g|gif|svg)(\?.*)?$/.toString()
    );
    const htmlWebpackPluginIndex = config.plugins.findIndex(
        plugin => plugin instanceof HtmlWebpackPlugin
    );
    const htmlWebpackPlugin = config.plugins.splice(htmlWebpackPluginIndex, 1)[0];
    notCssModules.splice(svgModulesIndex, 1);
    const webfontModulesIndex = notCssModules.findIndex(
        rule => rule.test.toString() == /\.(woff2?|eot|ttf|otf)(\?.*)?$/.toString()
    );
    notCssModules.splice(webfontModulesIndex, 1);
    const htmlWebpackPluginOptions = Object.assign({}, htmlWebpackPlugin.options);
    let renderConfig = {
        module: {
            rules: [{
                    test: /\.less$/,
                    oneOf: [{
                            resourceQuery: /module/,
                            use: [...cssHotLoader,"happypack/loader?id=modulesLess"]
                        },
                        {
                            use: [...cssHotLoader,"happypack/loader?id=less"]
                        },
                    ],
                },
                {
                    test: /\.s([ac])ss$/,
                    use: [...cssHotLoader,"happypack/loader?id=sass"]
                },
                {
                    test: /\.css$/,
                    use: [...cssHotLoader,"happypack/loader?id=css"]

                },
                {
                    test: /\.vue$/,
                    loader: "vue-loader",
                    options: {
                        cssModules: {
                            localIdentName: "[path][name]---[local]---[hash:base64:5]",
                            camelCase: true,
                        },
                        loaders: {
                            ...cssHotLoader,
                            less: "vue-style-loader!css-loader!less-loader",
                            scss: "vue-style-loader!css-loader!sass-loader",
                            sass: "vue-style-loader!css-loader!sass-loader",
                        },
                    },
                },
                {
                    test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
                    loader: "url-loader",
                    exclude: [resolve("src/assets/icons")],
                    options: {
                        esModule: false,
                        limit: 100,
                        name: "images/[name].[hash:8].[ext]",
                    },
                },
                {
                    test: /\.svg$/,
                    loader: "svg-sprite-loader",
                    include: [resolve("src/assets/icons")],
                    options: {
                        symbolId: "icon-[name]",
                    },
                },
                {
                    test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
                    loader: "url-loader",
                    options: {
                        esModule: false,
                        fallback: "file-loader?esModule=false",
                        limit: 100,
                        name: "font/[name].[hash:8].[ext]",
                    },
                },
            ],
        },
        plugins: [
            new HappyPack({
                id: "css",
                threadPool: happyThreadPool,
                loaders: ["css-loader"],
            }),
            new HappyPack({
                id: "less",
                threadPool: happyThreadPool,
                loaders: ["css-loader", "less-loader"],
            }),
            new HappyPack({
                id: "modulesLess",
                threadPool: happyThreadPool,
                loaders: [{
                        loader: "css-loader",
                        options: {
                            modules: true,
                            localIdentName: "[path][name]---[local]---[hash:base64:5]",
                            camelCase: true,
                        },
                    },
                    "less-loader"
                ],
            }),
            new HappyPack({
                id: "sass",
                threadPool: happyThreadPool,
                loaders: [
                    "css-loader",
                    "sass-loader",
                    {
                        loader: "sass-resources-loader",
                        options: {
                            resources: [
                                resolve("src/assets/sass/common.scss"),
                                resolve("src/assets/sass/common-mixin.scss"),
                            ],
                        },
                    }
                ],
            }),
            new HappyPack({
                // 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件
                id: "babel",
                // 如何处理 .js 文件，用法和 Loader 配置中一样
                loaders: ["babel-loader?cacheDirectory"],
                // 允许 HappyPack 输出日志
                verbose: false,
            }),
            new MiniCssExtractPlugin({
                filename: "[name].[hash:8].css",
                // chunkFilename: "css/[id].[hash:8].css",
                ignoreOrder: true,
            }),
            new HtmlWebpackPlugin({
                ...htmlWebpackPluginOptions,
                excludeChunks: ["preview", "contact"],
            }),
            // 在这里添加html
            new HtmlWebpackPlugin({
                ...htmlWebpackPluginOptions,
                inject: true,
                //html 文件名
                filename: "preview.html",
                title: "图片预览",
                chunks: ["icons", "vendors", "preview"],
            }),
            new HtmlWebpackPlugin({
                ...htmlWebpackPluginOptions,
                inject: true,
                filename: "contact.html",
                title: "选择联系人",
                chunks: ["icons", "vendors", "contact"],
                // excludeChunks: ["preview", "renderer"],
            }),
            // new webpack.HotModuleReplacementPlugin()
        ],
        entry: {
            preview: path.join(__dirname, "../../src/renderer/preview/preview.js"),
            contact: path.join(__dirname, "../../src/renderer/contact/index.js"),
        },
        output: {
            filename: "js/[name].[hash:8].js",
            chunkFilename: "js/[name].[hash:8].js",
            // libraryTarget: 'umd',
            libraryTarget: "commonjs2",
        },
        optimization: {
            minimizer: [],
            splitChunks: {
                chunks: "async",
                minSize: 30000,
                maxSize: 0,
                minChunks: 1,
                maxAsyncRequests: 5,
                maxInitialRequests: 3,
                automaticNameDelimiter: "~",
                name: true,
                cacheGroups: {
                    default: false,
                    vendors: {
                        test: /[\\/]node_modules[\\/](element-ui|vue|sockjs-client|core-js)[\\/]/,
                        name: "vendors",
                        chunks: "all",
                    },
                    icons: {
                        test: /([\\/]src\/components[\\/](Icons)[\\/])/,
                        name: "icons",
                        chunks: "all",
                    },
                },
            },
        },
    };
    if (config.optimization.minimize) {
        config.optimization.minimizer = [
            new TerserPlugin({
                terserOptions: {
                    compress: {
                        drop_debugger: true, //去掉debugger
                        drop_console: true, // 去掉console
                        pure_funcs: ["console.log"], // 移除console
                    },
                },
                parallel: true,
                sourceMap: false,
            }),
        ];
    }
    const ret = merge.smart(base, renderConfig);
    ret.module.rules = [...notCssModules, ...ret.module.rules];
    const miniCssExtractPluginIndex = config.plugins.findIndex(plugin => {
        return plugin.options && plugin.options.filename === "styles.css";
    });

    config.plugins.splice(miniCssExtractPluginIndex, 1);
    const res = merge.smartStrategy({
        "module.rules": "replace",
        entry: "append",
        plugins: "append",
        stats: "prepend",
        resolve: "append",
        watchOptions: "prepend",
    })(config, ret);
    return res;
};
```

 
