---
layout: post
filename: 2022-06-11-Fastiy学习
title: Fastiy学习
date: 2022-06-11 21:08:43 +0800
categories: Fastify
tags: Fastify
---

## 中文文档

[Fastify 文档中文翻译](https://github.com/fastify/docs-chinese#fastify-%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91)



## 安装

建立项目，并安装fastify

```shell
npm init
npm install fastify --save
```

可以限制node版本

```json
"engines": {
  "node": "~16.13.1"
},
```

简单样例：

**app.js**

同步代码：

```javascript
// 加载框架并新建实例
const fastify = require('fastify')({
  logger: true
})

// 声明路由
fastify.get('/', function (request, reply) {
  reply.send({ hello: 'world' })
})

// 启动服务！
fastify.listen(3000, function (err, address) {
  if (err) {
    fastify.log.error(err)
    process.exit(1)
  }
  fastify.log.info(`server listening on ${address}`)
})
```

异步代码：

```javascript
// 加载框架并新建实例
const fastify = require('fastify')({ logger: true })

// 声明路由
fastify.get('/', async (request, reply) => {
  return { hello: 'world' }
})

// 启动服务！
const start = async () => {
  try {
    await fastify.listen(3000)
    fastify.log.info(`server listening on ${fastify.server.address().port}`)
  } catch (err) {
    fastify.log.error(err)
    process.exit(1)
  }
}
start();
```



## 路由

### 注册一个路由

[Fastify路由中文文档](https://github.com/fastify/docs-chinese/blob/master/docs/Routes.md)

方法一：

```javascript
fastify.route({
  method: 'POST',
  url: '/api/log/jsons',
  handler: (req, res) => {
    req.body.on('data', d => console.log(d)) // log every incoming object
  }
})
```

方法二：

```javascript
router.on(['GET', 'POST'], '/example', (req, res, params) => {
  // your code
})
```

> 支持的method：'DELETE', 'GET', 'HEAD', 'PATCH', 'POST', 'PUT' 和 'OPTIONS'

### 简写定义

上文的路由定义带有 *Hapi* 的风格。要是偏好 *Express/Restify* 的写法，Fastify 也是支持的：
`fastify.get(path, [options], handler)`
`fastify.head(path, [options], handler)`
`fastify.post(path, [options], handler)`
`fastify.put(path, [options], handler)`
`fastify.delete(path, [options], handler)`
`fastify.options(path, [options], handler)`
`fastify.patch(path, [options], handler)`

示例：

```
const opts = {
  schema: {
    response: {
      200: {
        type: 'object',
        properties: {
          hello: { type: 'string' }
        }
      }
    }
  }
}
fastify.get('/', opts, (request, reply) => {
  reply.send({ hello: 'world' })
})
```

`fastify.all(path, [options], handler)` 会给所有支持的 HTTP 方法添加相同的处理函数。

处理函数还可以写到 `options` 对象里：

```
const opts = {
  schema: {
    response: {
      200: {
        type: 'object',
        properties: {
          hello: { type: 'string' }
        }
      }
    }
  },
  handler: function (request, reply) {
    reply.send({ hello: 'world' })
  }
}
fastify.get('/', opts)
```

> 注：假如同时在 `options` 和简写方法的第三个参数里指明了处理函数，将会抛出重复的 `handler` 错误。

### 清空路由

```javascript
router.reset()
```

### url支持格式

[https://github.com/delvedor/find-my-way#supported-path-formats](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fdelvedor%2Ffind-my-way%23supported-path-formats)

```javascript
// parametric
router.on('GET', '/example/:userId?', (req, res, params) => {}))
router.on('GET', '/example/:userId/:secretToken', (req, res, params) => {}))

// wildcard
router.on('GET', '/example/*', (req, res, params) => {}))

// parametric with regexp
router.on('GET', '/example/:file(^\\d+).png', () => {}))
```

> 注：关于异步路由，官方建议用[make-promises-safe](https://github.com/mcollina/make-promises-safe)，不过nodejs如果版本v15+, 不用也可以；



## 插件

就如同在 JavaScript 中一切皆为对象，在 Fastify 中，一切都是插件 (plugin)。在深入之前，先来看看插件系统是如何工作的吧！让我们新建一个基本的服务器，但这回我们把路由 (route) 的声明从入口文件转移到一个外部文件。

**app.js**

```javascript
const fastify = require('fastify')({
  logger: true
})

fastify.register(require('./our-first-route'))

fastify.listen(3000, function (err, address) {
  if (err) {
    fastify.log.error(err)
    process.exit(1)
  }
  fastify.log.info(`server listening on ${address}`)
})
```

**our-first-route.js**

```javascript
// our-first-route.js
async function routes (fastify, options) {
  fastify.get('/', async (request, reply) => {
    return { hello: 'world' }
  })
}
module.exports = routes
```

### 加入数据库操

如果上述方案加入数据库操作？

**app.js**

```javascript
const fastify = require('fastify')({
  logger: true
})

fastify.register(require('./our-db-connector'), {
  url: 'mongodb://localhost:27017/'
})

fastify.register(require('./our-first-route'))

fastify.listen(3000, function (err, address) {
  if (err) {
    fastify.log.error(err)
    process.exit(1)
  }
  fastify.log.info(`server listening on ${address}`)
})
```

**our-db-connector.js**

```javascript
const fastifyPlugin = require('fastify-plugin')
const MongoClient = require('mongodb').MongoClient

async function dbConnector (fastify, options) {
  const url = options.url
  delete options.url

  const db = await MongoClient.connect(url, options)
  //装饰器，给 Fastify 实例添加新mongo属性
  fastify.decorate('mongo', db)
}
// 用 fastify-plugin 包装插件，以使插件中声明的装饰器、钩子函数及中间件暴露在根作用域里。
module.exports = fastifyPlugin(dbConnector)
```

**our-first-route.js**

```javascript
async function routes (fastify, options) {
  //调用mongo属性
  const database = fastify.mongo.db('db')
  const collection = database.collection('test')

  fastify.get('/', async (request, reply) => {
    return { hello: 'world' }
  })

  fastify.get('/search/:id', async (request, reply) => {
    const result = await collection.findOne({ id: request.params.id })
    if (result.value === null) {
      throw new Error('Invalid value')
    }
    return result.value
  })
}

module.exports = routes
```

### 插件加载顺序

为了保证应用的行为一致且可预测，我们强烈建议你采用以下的顺序来组织代码：

```
└── 来自 Fastify 生态的插件
└── 你自己的插件
└── 装饰器
└── 钩子函数和中间件
└── 你的服务应用
```

这确保了你总能访问当前作用域下声明的所有属性。如前文所述，Fastify 提供了一个可靠的封装模型，它能帮助你的应用成为单一且独立的服务。假如你要为某些路由单独地注册插件，只需复写上述的结构就足够了。

```
└── 来自 Fastify 生态的插件
└── 你自己的插件
└── 装饰器
└── 钩子函数和中间件
└── 你的服务应用
    │
    └──  服务 A
    │     └── 来自 Fastify 生态的插件
    │     └── 你自己的插件
    │     └── 装饰器
    │     └── 钩子函数和中间件
    │     └── 你的服务应用
    │
    └──  服务 B
    │     └── 来自 Fastify 生态的插件
    │     └── 你自己的插件
    │     └── 装饰器
    │     └── 钩子函数和中间件
    │     └── 你的服务应用
```



## 装饰器

如果想为 Fastify 实例添加功能，可以使用 `decorate` 方法。

`decorate` 允许向 Fastify 实例添加新属性。可以是一个值、一个函数，也可以是一个对象或一个字符串等。

### 使用方法

**decorate**

只需要调用 `decorate` 函数，并且传入新属性的键和值即可。

```js
fastify.decorate('utility', () => {
	// something very useful
})
```

也可以定义其他类型的实例：

```js
fastify.decorate('conf', {
  db: 'some.db',
  port: 3000
})
```

一旦定义了这个实例，可以通过传入的参数名称来得到该值：

```js
fastify.utility()
console.log(fastify.conf.db)
```

装饰器不可以重新被覆盖，如果要定义一个已经存在的装饰器，`decorate` 将会抛出异常。

```js
fastify.decorate("d1", 'd1')

fastify.decorate("d1", "d2") // Error
```

**decorateReply**

`decorateReply` 可以为 `Reply` 对象添加新属性。

```js
fastify.decorateReply('utility', function () {
	// something very useful
})
```

**decorateRequest**

`decorateRequest` 可以为 `Request` 对象添加新属性。

```js
fastify.decorateRequest('utility', function () {
	// something very useful
})
```

**extendServerError**

如果要扩展 服务器错误，可以使用此 API，必须传入一个返回值为对象的函数，该函数将接收原始的 `Error` 对象，并返回新`Error` 对象来扩展服务器错误。

```js
fastify.extendServerError((err) => {
  return {
    timestamp: new Date()
  }
})
/*
最终的错误对象格式:
{
  error: String
  message: String
  statusCode: Number
  timestamp: Date
}
*/
```

#### 依赖

如果一个装饰器依赖于另一个装饰器，可以将其他装饰器声明为依赖。只需要添加一个字符串数组（表示所依赖的装饰器的名称）作为第三个参数即可：

```js
fastify.decorate('utility', fn, ['greet', 'log'])
```

如果不满足依赖关系，那么 `decorate` 会抛出一个异常，但是不用担心：依赖关系检查会在服务器启动之前执行，所以在运行时不会发生错误。

#### hasDecorator

可以使用 `hasDecorator` 检查装饰器是否存在：

```js
fastify.hasDecorator('utility')
```



## 验证数据

数据的验证在我们的框架中是极为重要的一环，也是核心的概念。Fastify 使用 [JSON Schema](http://json-schema.org/) 验证来访的请求。 让我们来看一个验证路由的例子：

```js
const opts = {
  schema: {
    body: {
      type: 'object',
      properties: {
        someKey: { type: 'string' },
        someOtherKey: { type: 'number' }
      }
    }
  }
}

fastify.post('/', opts, async (request, reply) => {
  return { hello: 'world' }
})
```

这个例子展示了如何向路由传递配置选项。选项中包含了一个名为 schema 的对象，它便是我们验证路由所用的模式 (schema)。借由 schema，我们可以验证 body、querystring、params 以及 header。请参阅[验证与序列化](https://github.com/fastify/docs-chinese/blob/master/docs/Validation-and-Serialization.md)获取更多信息。

## 序列化数据

Fastify 对 JSON 提供了优异的支持，极大地优化了解析 JSON body 与序列化 JSON 输出的过程。在 schema 的选项中设置 response 的值，能够加快 JSON 的序列化 (没错，这很慢！)，就像这样：

```js
const opts = {
  schema: {
    response: {
      200: {
        type: 'object',
        properties: {
          hello: { type: 'string' }
        }
      }
    }
  }
}

fastify.get('/', opts, async (request, reply) => {
  return { hello: 'world' }
})
```

简单地指明 schema，序列化的过程就达到了原先 2-3 倍的速度。这么做同时也保护了潜在的敏感数据不被泄露，因为 Fastify 仅对 schema 里出现的数据进行序列化。 请参阅 [验证与序列化](https://github.com/fastify/docs-chinese/blob/master/docs/Validation-and-Serialization.md)获取更多信息。

## 从命令行启动服务器

首先，你得安装 fastify-cli:

```
npm i fastify-cli
```

你还可以加入 -g 选项来全局安装它。

接下来，在 package.json 中添加如下行：

```
{
  "scripts": {
    "start": "fastify start server.js"
  }
}
```

然后，创建你的服务器文件：

```
// server.js
'use strict'

module.exports = async function (fastify, opts) {
  fastify.get('/', async (request, reply) => {
    return { hello: 'world' }
  })
}
```

最后，启动你的服务器：

```
npm start
```

## 测试

[测试](https://github.com/fastify/docs-chinese/blob/master/docs/Testing.md)
