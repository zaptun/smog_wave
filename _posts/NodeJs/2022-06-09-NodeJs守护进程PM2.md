---
 layout: post
filename: 2022-06-09-NodeJs守护进程PM2
title: NodeJs守护进程PM2
date: 2022-06-09 10:33:30 +0800
categories: NodeJS
tags: 守护进程 PM2
---



# pm2常用命令



原文链接：https://www.jianshu.com/p/7b10123c8b88

参考连接：https://juejin.cn/post/6889300755539312653

### 启动

`pm2 start app.js` （如果提示找不到命令且你已安装成功，则可能你没有配置环境变量，需要自己手动配一下）

**参数说明：**

- `--watch`：监听应用目录的变化，一旦发生变化，自动重启。如果要精确监听、不见听的目录，最好通过配置文件。
- `-i --instances`：启用多少个实例，可用于负载均衡。如果`-i 0`或者`-i max`，则根据当前机器核数确定实例数目。
- `--ignore-watch`：排除监听的目录/文件，可以是特定的文件名，也可以是正则。比如`--ignore-watch="test node_modules "`
- `-n --name`：指定应用的名称。查看应用信息的时候可以用到。
- `-o --output <path>`：标准输出日志文件的路径。
- `-e --error <path>`：错误输出日志文件的路径。
- `--interpreter <interpreter>`：the interpreter pm2 should use for executing app (bash, python...)。比如你用的coffee script来编写应用。
- `-x`：用fork模式启动app.js，而不是cluster模式

> - fork模式：单实例多进程，常用于多语言混编，比如php、python等，不支持端口复用，需要自己做应用的端口分配和负载均衡的子进程业务代码。
>   - 缺点：就是单服务器实例容易由于异常会导致服务器实例崩溃。
> - cluster模式：多实例多进程，但是只支持node，端口可以复用，不需要额外的端口配置，0代码实现负载均衡。
>   - 优点：就是由于多实例机制，可以保证服务器的容错性，就算出现异常也不会使多个服务器实例同时崩溃。

> 例子：
>
> - `pm2 start app.js --watch`：实时监控的方式启动，app.js文件有变动时，pm2会自动reload(重启)
> - `pm2 start app.js -i max`：根据有效CPU数目启动最大进程数目
> - `pm2 start app.js -i 3`：启动3个进程
> - `pm2 start app.js --ignore-watch="test node_modules"`:排除监听的目录/文件
> - `pm2 start app.js --name mynode`：启动一个进程并把它命名为mynode
> - `pm2 start app.json`：启动进程, 可以在 app.json里设置选项
> - `pm2 start app.js -i max - -z 10`：在 – 之后给 app.js 传递参数（-z 10）

### 查看与监视进程

- `pm2 list`：显示所有进程信息；
- `pm2 show 11`，`pm2 info 11`：查看进程id为 11 的详细信息；
- `pm2 monit`：进入监视页面，监视每个node进程的CPU和内存的使用情况。

### 重载、重启

- `pm2 restart 11`：重启id为 11 的进程；
- `pm2 restart all`：重启所有进程；
- `pm2 reload 11`：0秒停机重载id为 11 进程（用于 NETWORKED 进程）；
- `pm2 reload all`：重载所有进程；

### 停止、删除进程

- `pm2 stop/delete 11`：停止/删除id为 11 的进程；
- `pm2 stop/delete all`：停止/删除所有进程；

### 日志操作

- `pm2 logs`：显示所有进程的日志；
- `pm2 logs 11`：显示进程id为 11 的日志；
- `pm2 flush`：清空所有日志文件；
- `pm2 reloadLogs`：重载所有日志；
- `pm2 startup`：产生 init 脚本，保持进程活着；

### 杀进程

- `pm2 kill`：杀死pm2进程 ;

### 开机自动启动

1、通过`pm2 save`保存当前进程状态。
 2、通过`pm2 startup [platform]`生成开机自启动的命令。例如：`pm2 startup centeros`
 3、将步骤2生成的命令，粘贴到控制台进行，搞定。



##  pm2常用配置

pm2 配置方式



在上面的启动命令例子中，有一条`pm2 start app.json`命令，可以在app.json文件中添加配置

apps:json结构，apps是一个数组，数组中的每一个对象就对应一个pm2中运行的应用

**参数说明：**

- name:应用程序名称
- args:脚本的参数域
- cwd:应用程序所在的目录
- script:应用程序的脚本路径
- log_date_format:
- node_args:node 的参数域
- error_file:自定义应用程序的错误日志文件
- out_file:自定义应用程序日志文件
- pid_file:自定义应用程序的pid文件
- instances:
- min_uptime:最小运行时间，这里设置的是60s即如果应用程序在60s内退出，pm2会认为程序异常退出，此时触发重启max_restarts设置数量
- max_restarts:设置应用程序异常退出重启的次数，默认15次（从0开始计数）
- cron_restart:定时启动，解决重启能解决的问题
- watch:是否启用监控模式，默认是false。如果设置成true，当应用程序变动时，  pm2会自动重载。这里也可以设置你要监控的文件。
- merge_logs:
- exec_interpreter:应用程序的脚本类型，这里使用的shell，默认是nodejs
- exec_mode:应用程序启动模式，这里设置的是cluster_mode（集群），默认是fork
- autorestart:启用/禁用应用程序崩溃或退出时自动重启
- vizion:启用/禁用vizion特性(版本控制)

```json
{
  "apps": [
    {
      "name": "serverName", // 名称
      "script": "./index.js", // 入口文件
      "env": { // 环境
        "NODE_ENV": "development"
      },
      "env_production": {
        "NODE_ENV": "production"
      },
      "instances": 4, // 启用多少个实例
      "exec_mode": "cluster", // 应用程序启动模式，这里设置的是cluster_mode（集群），默认是fork
      "max_restarts" : 3, // 设置应用程序异常退出重启的次数，默认15次（从0开始计数）
      "restart_delay" : 5000, // 异常重启情况下，延时重启时间
      "log_date_format" : "YYYY-MM-DD HH:mm Z",
      "combine_logs" : true,
      "log_file": "<yourpath>/combined.outerr.log", // 日志目录
      "out_file": "<yourpath>/out.log",
      "error_file": "<yourpath>/err.log",
    }
  ]
}
```

> 注：`pm2 restart`命令不会重新进行 配置文件 需要关掉重启。

### fork与cluster启动模式

pm2启动进程的支持两种模式：fork与cluster，对于了解node的人知道，node的多进程编程api: child_process.fork与cluster。关于pm2的fork与cluster两者的本质区别，个人认为就是node API的child_process.fork与cluster的区别，stackoverflow有关于这个问题的讨论  http://stackoverflow.com/questions/34682035/cluster-and-fork-mode-difference-in-pm2。下面做个粗浅的归纳：

cluster是fork的派生，cluster支持所有cluster拥有的特性；

fork不支持socket地址端口复用，cluster支持地址端口复用。因为只有node的cluster模块支持socket选项SO_REUSEADDR；

fork不可以启动多个实例进程，cluster可以启动多个实例。但node的child_process.fork是可以实现启动多个进程的，但是为什么没有实现呢？就个人理解，node多为提供网络服务，启动多个实例需要地址端口复用，此时便可使用cluster模式实现，但fork模式并不支持地址端口复用，多实例进程启动会产生异常错误。但对于常驻任务脚本而言，不需要提供网络服务，此时多进程启动可以实现，同时也提高了任务处理效率。对于上述需求，可以两种方式实现，一是配置app0,app1,app2方式启动多个进程，二是通过应用实例自身调用child_process.fork多进程编程实现；

fork模式可以应用于其他语言，如php,python,perl,ruby,bash,coffee， 而cluster只能应用于node;

fork不支持定时重启，cluster支持定时重启。定时重启也就是配置中的cron_restart配置项。github上面有作者关于fork模式下是否需要实现cron-like定时的讨论：

https://github.com/Unitech/pm2/issues/496

### 启用cluster后报错问题

[参考 https://stackoverflow.com/questions/61908470/unable-to-create-node-script-cluster-with-pm2](https://stackoverflow.com/questions/61908470/unable-to-create-node-script-cluster-with-pm2)

关键的核心，因为 script 不能配置 command

之前代码大概这样

```json
{
  "apps" : [
      {
          "name"       : "main-server",
          "script"     : "npm start",
          "autorestart": true,
          "instances"  : 4,
          "exec_mode"  : "cluster"            
      }
  ]
}
```

改造后：

```json
{
  "apps" : [
      {
          "name": "main-server",
          "script": "./index.ts",
          "node_args": [
              "ts-node-dev",
              "--poll"
          ],
          "autorestart": true,
          "instances": 4,
          "exec_interpreter": "node",
          "exec_mode": "cluster",
          "env": {
              "NODE_ENV": "development"
          },
          "env_production": {
              "NODE_ENV": "production"
          }
      }
  ]
}
```

- `script` 调用一个文件，而不是NPM命令
- 参数放到 `node_args`
- `exec_interpreter` 配置成 `node` 或者绝对路径 e.g. `/usr/bin/nodejs`
- 定义 `env` 环境这点很重要



## pm2的监控

pm2的监控有两种方式：

cli方式监控

pm2 monit是专门用来监控的命令，监控项包括cpu与内存

缺点monit展示内容太过粗糙，不够详细

pm2 list展示当前所有pm2的管理项目

可以查看出每个进程的运行状态。

如果需要更详细的监控内容，对于cli而言一般都是可以实现的。

这种监控方式的缺点：

a. 不够直观，需要自己去执行命令并分析结果；

b. 不便于多台服务器的应用监控管理；

由于这些缺点，就需要一种更好的方式去监控我们的应用

keymetrics监控

keymetrics监控是PM2的开发者的开发和维护的一款监控工具，可以尝试一下，安装配置非常容易，我也只是粗浅的尝试了一下，可以参考

http://cnodejs.org/topic/56554300ad12df5d4e050b56

本人对监控研究不多，这里的监控主体是应用进程，非服务器，就只说说我比较喜欢的几个功能：

a. 利于多服务器监控管理；

b. 代码异常，可以看出程序长期运行中的稳定性；

c. 支持应用基本的启动，重启与停止等功能；

### 日志问题

日志系统对于任意应用而言，通常都是必不可少的一个辅助功能。pm2的相关文件默认存放于$HOME/.pm2/目录下，其日志主要有两类：

a. pm2自身的日志，存放于$HOME/.pm2/pm2.log；

b. pm2所管理的应用的日志，存放于$HOME/.pm2/logs/目录下，标准谁出日志存放于${APP_NAME}_out.log，标准错误日志存放于${APP_NAME}_error.log；

这里之所以把日志单独说明一下是因为，如果程序开发不严谨，为了调试程序，导致应用产生大量标准输出，使服务器本身记录大量的日志，导致服务磁盘满载问题。一般而言，pm2管理的应用本身都有自己日志系统，所以对于这种不必要的输出内容需禁用日志，重定向到/dev/null。

与crontab比较，也有类似情况，crontab自身日志，与其管理的应用本身的输出。应用脚本输出一定需要重定向到/dev/null，因为该输出内容会以邮件的形式发送给用户，内容存储在邮件文件，会产生意向不到的结果，或会导致脚本压根不被执行；

## 稳定运行建议

PM2是一款非常优秀的Node进程管理工具，它有着丰富的特性：能够充分利用多核CPU且能够负载均衡、能够帮助应用在崩溃后、指定时间(cluster model)和超出最大内存限制等情况下实现自动重启。

个人几点看法保证常驻应用进程稳定运行：

1. 定时重启，应用进程运行时间久了或许总会产生一些意料之外的问题，定时可以规避一些不可测的情况；

2. 最大内存限制，根据观察设定合理内存限制，保证应用异常运行；

3. 合理min_uptime，min_uptime是应用正常启动的最小持续运行时长，超出此时间则被判定为异常启动；

4. 设定异常重启延时restart_delay，对于异常情况导致应用停止，设定异常重启延迟可防止应用在不可测情况下不断重启的导致重启次数过多等问题；

5. 设置异常重启次数，如果应用不断异常重启，并超过一定的限制次数，说明此时的环境长时间处于不可控状态，服务器异常。此时便可停止尝试，发出错误警告通知等。

关于pm2的使用，主要还是运用于常驻脚本。定时任务，更多还是需要专门的定时任务管理工具crontab，不过crontab在使用中总会有各种不爽的问题，提供一个链接，关于crontab的问题，以及提出了一个新工具jobCenter，本人暂未仔细研究，粗略看了一下好像还不错:

http://mp.weixin.qq.com/s?__biz=MzA3MzYwNjQ3NA%3D%3D&from=timeline&hmsr=toutiao.io&idx=1&isappinstalled=0&mid=208434536&scene=2&sn=be02773ef6bb90ad56a7b4333dd119f5&srcid=0929FOcv2W14C8OaztPznanb&utm_medium=toutiao.io&utm_source=toutiao.io

对于工具使用，于人而言，什么工具不是最重要的，而是在于人。这个道理很多人都是清楚明白。对于互联网it行业，如今各种开源软件繁多，每种使用场景下的工具通常都不止一种。对于公司而言，一个新的工具上线，一定是需要一位十分精通的人去引进并进行答疑解惑，以避免再好的工具也被滥用的情况发生。



-----



## 服务器自动化部署

### 生成部署文件

找一个位置生成ecosystem.config.js部署文件

```shell
pm2 ecosystem
```

```json
module.exports = {
  apps : [{
    script: 'index.js',
    watch: '.'
  }, {
    script: './service-worker/',
    watch: ['./service-worker']
  }],

  deploy : {
    production : {
      user : 'SSH_USERNAME',
      host : 'SSH_HOSTMACHINE',
      ref  : 'origin/master',
      repo : 'GIT_REPOSITORY',
      path : 'DESTINATION_PATH',
      'pre-deploy-local': '',
      'post-deploy' : 'npm install && pm2 reload ecosystem.config.js --env production',
      'pre-setup': ''
    }
  }
};
```

### 启动

```shell
pm2 start //会自动读取ecosystem.config.js内的配置
```

### 配置开机自起

`pm2 startup [platform]`生成开机自启动的命令。例如：

```shell
//查看当前系统信息
uname -a

//启动服务
pm2 start

//保存当前已经启动了的服务
pm2 save

//设置开机⾃启的配置
pm2 startup

//或者指定系统平台(systemd是Linux 系统工具)
pm2 unstartup [ubuntu | ubuntu14 | ubuntu12 | centos | centos6 | arch | oracle | amazon | macos | darwin | freesd | systemd | systemv | upstart | launchd | rcd | openrc] 

//禁止开机启动
pm2 unstartup

//mac查看启动的端口
netstat -AaLlnW

//linux查看启动的端口
netstat -nultp
```

